<!-- SYNC IMPACT REPORT -->
<!-- Version Change: 1.1.0 → 1.2.0 -->
<!-- Modified Principles: Added emphasis on stateless architecture in Phase 3 section -->
<!-- Added Sections: None -->
<!-- Removed Sections: None -->
<!-- Templates Requiring Updates: None -->
<!-- Deferred Placeholders: None -->

# Hackathon II: Todo Full-Stack Web Application Constitution

**Project**: Multi-user Full-Stack Todo Web Application with AI Chatbot
**Phases**: Phase 2 of 5 (Full-Stack Web Application) + Phase 3 of 5 (AI Chatbot Integration)
**Development Methodology**: Strict Spec-Driven Development (SDD) with Claude Code + Spec-Kit Plus

---

## Table of Contents

- [Core Principles](#core-principles)
- [Phase 2: Full-Stack Web App](#phase-2-full-stack-web-app)
- [Phase 3: Todo AI Chatbot](#phase-3-todo-ai-chatbot)
- [Technology Stack](#technology-stack)
- [Governance & Versioning](#governance--versioning)

---

## Core Principles

### I. Strict Spec-Driven Development (NON-NEGOTIABLE)

Every feature, component, API endpoint, database schema, and configuration change MUST begin with a detailed Markdown specification:

- **Specification First**: No code is written until specs are approved
- **Iterative Refinement**: Refine specs through multiple iterations until Claude Code generates correct, complete implementation
- **Complete Documentation**: All specs must include user stories, acceptance criteria, edge cases, error handling, and test scenarios
- **AI as Implementer**: Claude Code handles ALL syntax, boilerplate, and implementation details

**Workflow**: `/sp.specify → /sp.clarify → /sp.plan → /sp.tasks → /sp.analyze → /sp.implement`

### II. No Manual Coding Allowed (NON-NEGOTIABLE)

ALL code (frontend, backend, database, config, tests) MUST be generated by Claude Code:

- **Zero Manual Edits**: Manual code writing or editing is strictly prohibited
- **Fix via Specs**: Issues are resolved by improving specifications and re-generating code
- **Human as Architect**: Developer role is limited to system architect—write/refine specs, plans, and prompts
- **AI Handles Implementation**: Claude Code generates all syntax, patterns, and boilerplate

**Rationale**: Ensures consistency, maintainability, and demonstrates pure spec-driven methodology for hackathon judging.

### III. Test-Driven Development (TDD) - NON-NEGOTIABLE

ALL code must be developed using strict Test-Driven Development with Red-Green-Refactor cycle:

- **Red**: Write failing test FIRST (defines expected behavior)
- **Green**: Write minimal code to make test pass
- **Refactor**: Improve code quality while keeping tests green
- **No Code Without Tests**: Production code is written ONLY after failing test exists

**TDD Workflow**: `/sp.specify → /sp.plan → /sp.tasks → /sp.red → /sp.green → /sp.refactor`

**Testing Requirements:**
- **Backend**: 80%+ overall coverage, 100% for authentication and security
- **Frontend**: 70%+ overall coverage, 90%+ for critical components
- **E2E**: 100% coverage for critical user flows
- **Security Tests**: MANDATORY (user isolation, SQL injection, XSS)

**Test Specifications**: See `@specs/testing/` for complete testing requirements

### IV. Use Subagents and Skills

- **Explore Agent**: Use for codebase exploration and understanding (`subagent_type=Explore`)
- **Plan Agent**: Use for architecture and design decisions (`subagent_type=Plan`)
- **Skills**: Leverage `/sp.*` skills for spec-driven workflows
- **Task Agent**: Use for complex multi-step operations (`subagent_type=general-purpose`)

### V. Context7 MCP Server for Documentation

- **Mandatory Documentation Lookup**: Before using any technology, library, or framework, MUST read official documentation using Context7 MCP server
- **Technologies Requiring Lookup**:
  - Next.js 15+ (App Router)
  - FastAPI
  - SQLModel
  - Better Auth
  - Neon PostgreSQL
  - shadcn/ui
  - GSAP & Framer Motion
  - OpenAI Agents SDK (Phase 3)
  - Official MCP SDK (Phase 3)
  - OpenAI ChatKit (Phase 3)
- **Pattern**: `mcp__context7__resolve-library-id` → `mcp__context7__query-docs`

### VI. User Data Isolation & Security (CRITICAL)

Multi-user support with absolute user isolation:

- **Ownership Enforcement**: Every task belongs to exactly one user (enforced at database level)
- **Authorization Checks**: ALL API endpoints verify JWT token and user_id matching
- **No Cross-User Access**: Users CANNOT view, modify, or delete other users' tasks
- **Security Testing**: Test plans must include unauthorized access attempts (MANDATORY)
- **Fail-Secure**: Invalid/missing tokens → 401 Unauthorized
- **Test Coverage**: 100% coverage required for all security-related code

### VII. Model Context Protocol (MCP) - Phase 3 CRITICAL

MCP provides standardized interfaces for AI agents to interact with task management:

- **MCP Server Architecture**: Stateless MCP server exposes task operations as tools
- **Tool-Based Operations**: All task modifications via MCP tools (add_task, list_tasks, complete_task, delete_task, update_task)
- **Stateless Design**: Server maintains NO state; all conversation/task state persisted to database
- **Tool Parameters**: All tools include required `user_id` parameter for security isolation
- **Tool Returns**: Standardized response format with operation status and affected task details
- **Error Handling**: Tools gracefully handle "task not found" and other errors with descriptive messages
- **Security**: MCP tools enforce same JWT + user_id validation as REST API endpoints

**MCP Tools Specification:**
- `add_task(user_id, title, description)` → Returns task_id, status, title
- `list_tasks(user_id, status="all"|"pending"|"completed")` → Returns array of task objects
- `complete_task(user_id, task_id)` → Returns task_id, status, title
- `delete_task(user_id, task_id)` → Returns task_id, status, title
- `update_task(user_id, task_id, title, description)` → Returns task_id, status, title

### VIII. Modular & Future-Ready Design

Build with clean architecture for easy evolution into future phases:

- **Phase III Ready**: AI chatbot integration with MCP tools
- **Phase IV Ready**: Kubernetes deployment structure
- **Phase V Ready**: Event-driven architecture patterns
- **Clean Separation**: Frontend ↔ API ↔ Business Logic ↔ Data Layer ↔ MCP Server
- **Versioned APIs**: API versioning strategy for backward compatibility

### IX. Design Excellence (CRITICAL)

**Dashboard-Like Experience**: Build a modern, professional dashboard interface with fantastic UX that rivals premium SaaS applications.

**UI/UX Requirements**:
- **Dashboard Layout**: Sidebar navigation, main content area with cards/panels, header with user profile
- **Visual Hierarchy**: Clear information architecture with proper spacing, grouping, and visual weight
- **Typography**: Use `JetBrains Mono` (code/monospace) and `Inter` (body text) fonts for premium feel
- **Glassmorphism**: Apply backdrop-blur effects for depth, layering, and modern aesthetic
- **Component Library**: Use shadcn/ui for consistent, accessible, production-ready components
- **No Inline Styles**: ALL styling via Tailwind CSS classes (maintainability and consistency)
- **Smooth Animations**: GSAP and Framer Motion for delightful micro-interactions and page transitions
- **Responsive Design**: Mobile-first approach with seamless breakpoints for tablet/desktop
- **Dark Mode Support**: Toggle between light/dark themes with smooth transitions
- **Interactive Feedback**: Hover states, loading skeletons, toast notifications, confirmation modals
- **Data Visualization**: Progress indicators, task completion stats, priority distributions
- **Intuitive Navigation**: Keyboard shortcuts, breadcrumbs, search with instant results
- **Performance**: 60fps animations, optimized images, lazy loading, minimal layout shifts

**UX Excellence Standards**:
- Every interaction should feel instant and responsive
- Zero confusion - users should intuitively understand how to complete tasks
- Delight users with subtle animations and polished details
- Accessibility first - WCAG 2.1 AA compliance minimum
- Error states that guide users to resolution
- Empty states that encourage action

**UI/UX Specifications**: See `@specs/ui/` for comprehensive design system documentation:
- `@specs/ui/design-system.md` - Complete design tokens (colors, typography, spacing, shadows, glassmorphism)
- `@specs/ui/dashboard-layout.md` - Layout structure for desktop, tablet, mobile (sidebar, header, content)
- `@specs/ui/glassmorphism.md` - Glassmorphism patterns and implementation (backdrop-blur, layering, depth)
- `@specs/ui/animations.md` - GSAP & Framer Motion specifications (60fps micro-interactions, transitions)
- `@specs/ui/responsive-design.md` - Mobile-first responsive patterns (breakpoints, touch targets, adaptive layouts)
- `@specs/ui/dark-mode.md` - Theme toggle implementation (next-themes, color variables, smooth transitions)
- `@specs/ui/accessibility.md` - WCAG 2.1 AA compliance (keyboard nav, screen readers, ARIA, color contrast)

### X. AI Chatbot Integration (Phase 3 Specific)

Phase 3 extends Phase 2 with conversational AI for task management:

- **Conversational Interface**: Natural language task creation, queries, and management
- **Stateless Server Architecture**: All conversation state persisted to database; server maintains no state between requests
- **MCP Tool Integration**: AI agent uses MCP tools for all task operations (no direct database access)
- **User Authentication Required**: Chatbot access requires valid JWT token; inherits Phase 2 security model
- **Task Summary on Login**: Chatbot provides task overview (total tasks, completed, pending, priorities) from logged-in user data
- **Theme Consistency**: Chatbot UI color/theme matches Phase 2 app (same design system, dark mode support)
- **Basic Features Only**: Phase 3 focuses on Basic Level features via natural language (Level 2/3 features in future phases)

---

## Phase 2: Full-Stack Web App

### Overview

Phase 2 establishes the foundation: multi-user task management with persistent storage, JWT authentication, and polished UI/UX.

---

## Technology Stack

### Phase 2 Stack

### Frontend
- **Framework**: Next.js 15+ with App Router
- **Language**: TypeScript (strict mode)
- **Styling**: Tailwind CSS (no inline styles)
- **Components**: shadcn/ui
- **Animations**: GSAP + Framer Motion
- **Fonts**: JetBrains Mono, Inter
- **Design**: Glassmorphism (backdrop-blur effects)

### Backend
- **Language**: Python 3.13+
- **Package Manager**: UV
- **Framework**: FastAPI
- **ORM**: SQLModel
- **Database**: Neon Serverless PostgreSQL
- **Authentication**: Better Auth with JWT tokens

### Phase 3 AI Stack

- **Frontend Chat UI**: OpenAI ChatKit (hosted)
- **AI Framework**: OpenAI Agents SDK
- **MCP Implementation**: Official MCP SDK
- **LLM Provider**: OpenAI API (GPT-4 or later)
- **Integration Pattern**: Stateless FastAPI endpoint + MCP server with database persistence

### Development Tools
- **AI Development**: Claude Code (Sonnet 4.5)
- **Spec Framework**: Spec-Kit Plus
- **Version Control**: Git
- **Environment**: WSL 2 (for Windows users)

### Deployment
- **Frontend (Phase 2)**: Vercel or GitHub Pages
- **Backend (Phase 2)**: Hugging Face Spaces
- **Chatbot UI (Phase 3)**: OpenAI ChatKit (hosted)
- **MCP Server (Phase 3)**: FastAPI endpoint on Hugging Face Spaces
- **Database**: Neon (serverless PostgreSQL, shared with Phase 2)

---

## API Design Standards

### Base URL Structure
All API endpoints follow user-scoped pattern:
```
/api/{user_id}/...
```

### Required Endpoints

| Method | Endpoint | Description | Auth Required |
|--------|----------|-------------|---------------|
| GET | `/api/{user_id}/tasks` | List user's tasks (with filters/sort) | ✓ |
| POST | `/api/{user_id}/tasks` | Create new task | ✓ |
| GET | `/api/{user_id}/tasks/{id}` | Get task details | ✓ |
| PUT | `/api/{user_id}/tasks/{id}` | Update task | ✓ |
| DELETE | `/api/{user_id}/tasks/{id}` | Delete task | ✓ |
| PATCH | `/api/{user_id}/tasks/{id}/complete` | Toggle completion | ✓ |

### Authentication Flow
1. **JWT Tokens**: Better Auth configured for JWT issuance
2. **Token Secret**: Shared secret via `BETTER_AUTH_SECRET` env var
3. **Authorization Header**: `Authorization: Bearer <token>`
4. **Token Verification**: Backend middleware validates JWT on every request
5. **User ID Enforcement**: Middleware extracts `user_id` from token, verifies match with URL param
6. **Token Expiry**: 7 days (configurable)
7. **Unauthorized Response**: 401 with clear error message

### Phase 3 Chat API Endpoints

| Method | Endpoint | Description | Auth Required |
|--------|----------|-------------|---------------|
| POST | `/api/{user_id}/chat` | Send message & get AI response | ✓ |

**Chat Request:**
```json
{
  "conversation_id": "optional-uuid-or-null",
  "message": "Add a task to buy groceries"
}
```

**Chat Response:**
```json
{
  "conversation_id": "uuid",
  "response": "I've added 'Buy groceries' to your tasks.",
  "tool_calls": [
    {
      "tool": "add_task",
      "parameters": {"user_id": "xyz", "title": "Buy groceries", "description": null},
      "result": {"task_id": 5, "status": "created", "title": "Buy groceries"}
    }
  ]
}
```

**Chat Flow (Stateless, Database-Persisted State):**
1. Receive user message + optional conversation_id
2. Fetch conversation history from database (if conversation_id provided)
3. Build message array for AI agent (history + new message)
4. Store user message in Conversation.messages
5. Execute agent with MCP tools (agent calls tools as needed)
6. Store assistant response in Conversation.messages
7. Return response + tool invocations to client
8. Server maintains NO state (horizontally scalable)

---

## Feature Implementation Levels

### Level 1: Basic CRUD (Foundation)
- **Add Task**: Create with title and description
- **View Tasks**: List all user's tasks
- **Update Task**: Modify title/description
- **Delete Task**: Remove task (with confirmation)
- **Mark Complete**: Toggle task completion status

### Level 2: Intermediate Features (Organization)
- **Priority Levels**: HIGH (Red), MEDIUM (Yellow), LOW (Green), NONE
- **Tags/Categories**: Multi-tag support (comma-separated, max 20 chars each)
- **Search**: Keyword search across title/description (case-insensitive)
- **Filter**: By status (todo/done), priority, or tags (ANY-match logic)
- **Sort**: By Priority, Created Date, Title, or Due Date (with secondary sorting)

### Level 3: Advanced Features (Intelligence)
- **Recurring Tasks**: DAILY, WEEKLY, MONTHLY patterns
  - Auto-reschedule on completion or due date passage
  - Edge case handling (Feb 29, month-end dates)
- **Due Dates & Times**: DateTime precision (YYYY-MM-DD HH:MM)
  - Future validation
  - Browser notifications for due-soon tasks
- **Smart Reminders**:
  - Overdue detection (tasks past due datetime)
  - Due Soon alerts (within 60 minutes)
  - Browser notification API integration

---

## Database Schema (Phase 2 + Phase 3)

### Phase 2 Core Tables

| Table | Columns | Purpose |
|-------|---------|---------|
| **users** | id (UUID), email (unique), password_hash, name, created_at, updated_at, email_verified | User accounts |
| **tasks** | id (UUID), user_id (FK), title, description, completed, priority, tags (array), due_date, is_recurring, recurrence_pattern, created_at, updated_at, completed_at | Todo items |

### Phase 3 Extension Tables

| Table | Columns | Purpose |
|-------|---------|---------|
| **conversations** | id (UUID), user_id (FK), created_at, updated_at | Chat sessions (one per conversation thread) |
| **messages** | id (UUID), user_id (FK), conversation_id (FK), role (enum: "user"|"assistant"), content (text), created_at | Chat history (immutable, indexed by conversation_id) |

**Key Design Decisions:**
- Conversations table enables session resumption (user can continue conversation from previous session)
- Messages table maintains complete history for context (AI agent pulls conversation history for context)
- Both tables include user_id for efficient filtering and security isolation
- Messages are immutable (no updates/deletes, only appends)
- Indexes on (user_id, conversation_id) for fast history retrieval

---

## Monorepo Structure

```
Phase02_FullStackWebApp/
├── .specify/                    # Spec-Kit Plus framework
│   ├── config.yaml             # Monorepo configuration
│   ├── memory/
│   │   └── constitution.md     # This file
│   ├── templates/              # Spec templates
│   └── scripts/                # Automation scripts
├── specs/                      # Feature specifications
│   ├── features/
│   │   ├── authentication/
│   │   ├── task-crud/
│   │   └── ai-chatbot/         # Phase 3 specs
│   │       ├── spec.md
│   │       ├── plan.md
│   │       └── tasks.md
│   ├── api/
│   │   ├── rest-endpoints.md
│   │   └── mcp-tools.md        # Phase 3 MCP spec
│   ├── database/
│   │   └── schema.md           # Phase 2 + Phase 3
│   └── testing/
├── history/
│   ├── prompts/                # PHRs organized by feature
│   │   ├── phase-2/
│   │   └── phase-3/
│   └── adr/                    # Architecture Decision Records
├── frontend/                   # Next.js application (Phase 2)
│   ├── CLAUDE.md              # Frontend-specific guidelines
│   ├── app/
│   ├── components/
│   ├── lib/
│   └── package.json
├── backend/                    # FastAPI application (Phase 2 + Phase 3)
│   ├── CLAUDE.md              # Backend-specific guidelines
│   ├── app/
│   │   ├── main.py           # FastAPI entry point
│   │   ├── models/           # SQLModel models (Phase 2 + Phase 3)
│   │   ├── routes/           # API endpoints (Phase 2 + Phase 3)
│   │   ├── services/         # Business logic
│   │   ├── middleware/       # Auth, CORS, etc.
│   │   └── mcp/              # MCP server implementation (Phase 3)
│   ├── tests/
│   └── pyproject.toml
├── CLAUDE.md                   # Root guidelines
└── README.md                   # Project documentation
```

---

## Authentication & Security Standards

### JWT Token Implementation
- **Library**: Better Auth (configured for JWT)
- **Secret Management**: `BETTER_AUTH_SECRET` environment variable (never committed)
- **Token Payload**: Must include `user_id`, `email`, `exp` (expiry), `iat` (issued at)
- **Token Storage**: HttpOnly cookies (frontend) or localStorage (with XSS precautions)
- **Token Expiry**: 7 days (refresh tokens optional for Phase 3)

### Security Requirements
1. **Password Hashing**: bcrypt or argon2 (via Better Auth)
2. **SQL Injection Prevention**: SQLModel parameterized queries only
3. **XSS Protection**: Input sanitization, Content-Security-Policy headers
4. **CORS Configuration**: Restrict origins (localhost for dev, production domains for deploy)
5. **Rate Limiting**: 100 requests/minute per user (prevent abuse)
6. **Error Messages**: Never expose sensitive details (DB structure, stack traces)

### User Isolation Tests (Required)
- Attempt to access `/api/{other_user_id}/tasks` with valid but different user token → 401
- Attempt to modify `/api/{other_user_id}/tasks/{id}` → 401
- Token expiry verification (7 days + 1 minute) → 401
- Invalid/malformed token → 401
- Missing Authorization header → 401

---

## Phase 3: Todo AI Chatbot

### Overview

Phase 3 extends Phase 2 by adding conversational AI for natural language task management. Users can interact with their tasks through a chat interface powered by OpenAI Agents SDK and MCP tools.

### Core Features

| Feature | Description |
|---------|-------------|
| **Natural Language Tasks** | Create tasks by saying "Add a task to buy groceries" |
| **Task Queries** | Ask "Show me all my tasks" or "What's pending?" |
| **Task Completion** | Say "Mark task 3 as complete" |
| **Task Updates** | "Change task 1 to 'Call mom tonight'" |
| **Task Deletion** | "Delete the meeting task" |
| **Task Summary** | Chatbot provides overview on login (total, completed, pending, priorities) |
| **Conversation Context** | Chat maintains multi-turn context; user can continue conversations |
| **Stateless Server** | Server handles requests independently; all state in database |

### Agent Behavior Specification

| User Input | Agent Action | MCP Tool Called |
|-----------|--------------|-----------------|
| "Add a task to buy groceries" | Extract title, call tool | `add_task(user_id, "Buy groceries", null)` |
| "Show me all my tasks" | Fetch all tasks | `list_tasks(user_id, "all")` |
| "What's pending?" | Fetch pending tasks | `list_tasks(user_id, "pending")` |
| "Mark task 3 as complete" | Toggle completion | `complete_task(user_id, 3)` |
| "Delete the meeting task" | Find & delete task | `list_tasks(...)` then `delete_task(user_id, task_id)` |
| "Change task 1 to 'Call mom tonight'" | Update title | `update_task(user_id, 1, "Call mom tonight", null)` |
| "What have I completed?" | Show done tasks | `list_tasks(user_id, "completed")` |
| "I need to remember to pay bills" | Create task | `add_task(user_id, "Pay bills", null)` |

**Agent Behavior Rules:**
- Always confirm actions with friendly response
- Gracefully handle "task not found" errors
- Extract context from conversation history
- Parse natural language for task titles/descriptions
- Chain tools when needed (e.g., list first to find task by name, then delete)
- Never expose internal errors to user (handle gracefully)
- Keep responses conversational and helpful

### OpenAI ChatKit Configuration

**Domain Allowlist Setup (Required for Production):**
1. Deploy frontend to Vercel/GitHub Pages (get production URL)
2. Add domain to OpenAI allowlist: https://platform.openai.com/settings/organization/security/domain-allowlist
3. Receive domain key from OpenAI
4. Configure in frontend: `NEXT_PUBLIC_OPENAI_DOMAIN_KEY=<key>`

**Local Development:**
- ChatKit works on `localhost` without domain key configuration
- Set `NEXT_PUBLIC_OPENAI_API_KEY` for local testing (optional, uses hosted ChatKit keys)

**Environment Variables (Phase 3):**
```bash
# Backend
OPENAI_API_KEY=sk-xxxxx              # OpenAI API key for Agents SDK
OPENAI_ORGANIZATION=org-xxxxx        # Optional: OpenAI organization ID

# Frontend (for ChatKit)
NEXT_PUBLIC_OPENAI_DOMAIN_KEY=dk-xxxxx  # ChatKit domain key (production)
NEXT_PUBLIC_OPENAI_API_KEY=sk-xxxxx     # Optional: For local development
```

### Phase 3 Testing Requirements

**Chat Flow Tests (100% Coverage):**
- Message creation and persistence
- Tool invocation and execution
- Conversation history retrieval
- User isolation (cross-user access prevented)
- Error handling (malformed requests, tool failures)
- Stateless behavior (server restart doesn't lose conversation)

**Natural Language Understanding Tests:**
- Task creation from various phrasings
- Task query variations
- Ambiguous input handling
- Typo tolerance

**Security Tests (100% Coverage):**
- Cross-user chat access attempts → 401
- Missing JWT token → 401
- Expired token → 401
- User_id URL mismatch → 403

**MCP Tool Tests (100% Coverage):**
- Each tool with valid parameters
- Each tool with invalid parameters
- Each tool with missing user_id
- Tool error scenarios

### Phase 3 Success Criteria

- ✅ AI understands 90%+ of Basic Level task commands
- ✅ Chat endpoint responds < 500ms
- ✅ Conversation history persists across sessions
- ✅ MCP tools execute correctly with proper isolation
- ✅ 100% test coverage for auth/security/chat flows
- ✅ Chatbot theme matches Phase 2 app design
- ✅ Zero manual code (all AI-generated from specs)
- ✅ Server stateless and horizontally scalable

### Phase 3 Deployment

- **Frontend Chat UI**: OpenAI ChatKit (hosted)
  - Deploys to OpenAI's infrastructure (no deployment needed)
  - Requires domain allowlist configuration
  - Supports dark mode matching Phase 2 app

- **MCP Server**: FastAPI endpoint on Hugging Face Spaces
  - Same deployment as Phase 2 backend
  - Adds `/api/{user_id}/chat` endpoint
  - Reuses existing database and authentication

- **Database**: Neon PostgreSQL (shared with Phase 2)
  - Adds `conversations` and `messages` tables
  - Maintains user isolation across both phases

## Phase 3: Agents and Their Skills

Phase 3 AI chatbot implementation is built on two specialized agents, each with dedicated skills for specific responsibilities:

### Agent 1: MCP Server Builder

The MCP Server Builder agent develops and validates MCP tools that serve as the interface between the OpenAI Agent and the backend database. It is supported by three specialized skills:

#### **1. MCP Tool Definition & Schema Validation Skill**
- **Location**: `.claude/skills/mcp-tool-definition/SKILL.md`
- **Owner**: mcp-server-builder agent
- **Purpose**: Generates standardized MCP tool schemas using Official MCP SDK patterns
- **Responsibilities**:
  - Define 5 core tools (add_task, list_tasks, complete_task, delete_task, update_task) with complete specifications
  - Provide JSON Schema validation templates for all parameters
  - Define standardized error response format with 7 error codes (invalid_parameter, task_not_found, unauthorized_access, authentication_required, database_error, rate_limit_exceeded, invalid_state)
  - Document tool composability patterns (Find & Update, Find & Delete, Task Summary)
  - Specify rate limiting per tool (add_task: 100/min, list_tasks: 500/min, complete_task: 100/min, delete_task: 50/min, update_task: 100/min)
  - Include security & authorization checklist with 100% coverage requirements
- **Usage Phase**: Schema definition phase; before writing any tool implementation

#### **2. MCP Tool Security & Integration Testing Skill**
- **Location**: `.claude/skills/mcp-tool-security-testing/SKILL.md`
- **Owner**: mcp-server-builder agent
- **Purpose**: Generates comprehensive pytest test suite following TDD Red-Green-Refactor cycle
- **Responsibilities**:
  - Generate failing tests (Red phase) that define expected tool behavior
  - Ensure 100% test coverage for: authentication/JWT validation, cross-user access prevention (CRITICAL), parameter validation, error handling
  - Create security-critical tests: Unauthorized access returns 403, cross-user task operations are blocked, invalid tokens return 401
  - Verify tool composition tests: list+update, list+delete sequences work correctly
  - Mock OpenAI Agents SDK tool invocation patterns for integration testing
  - Validate conversation context tests: Multi-turn message history availability
  - Test concurrent operations: Race condition detection, simultaneous request handling
  - Validate rate limiting: Per-user limit enforcement with 429 responses
- **Usage Phase**: Test generation phase; during TDD Red phase before implementation

#### **3. Stateless Database Integration & Persistence Skill**
- **Location**: `.claude/skills/stateless-db-persistence/SKILL.md`
- **Owner**: mcp-server-builder agent
- **Purpose**: Defines stateless request-response patterns and SQLModel database integration
- **Responsibilities**:
  - Define per-request session lifecycle: Create → Execute → Commit/Rollback → Close (stateless guarantee)
  - Optimize connection pool: pool_size=5, max_overflow=10, pool_timeout=30, pool_recycle=3600
  - Implement transaction safety patterns: Atomic operations, savepoints, conflict detection
  - Provide error recovery: Retry logic with exponential backoff, idempotency keys
  - Define conversation history retrieval: Efficient queries for multi-turn AI context
  - Specify database schema: Conversation & Message tables with indexes for user_id and created_at
  - Provide Alembic migration templates: Version-controlled schema evolution
  - Implement performance optimization: Pagination, lazy loading prevention, N+1 query prevention
- **Usage Phase**: Tool implementation phase (Green phase) for database operations; query optimization

#### **MCP Server Builder Skills Integration Workflow**

The three skills work together in sequence during Phase 3 MCP server development:

1. **Schema Phase** (Skill 1):
   - Define tool schemas and contracts from specification
   - Document parameter validation rules
   - Specify error codes and rate limits

2. **Test Phase** (Skill 2):
   - Generate failing tests (TDD Red phase)
   - Tests define expected tool behavior
   - Ensure 100% coverage of security, error handling, edge cases

3. **Implementation Phase** (Skill 3):
   - Implement tool functions using stateless patterns
   - Use per-request session lifecycle
   - Ensure atomic transactions and proper error recovery

4. **Validation Phase** (All Skills):
   - Run tests to verify implementation (TDD Green phase)
   - Validate schemas against MCP SDK specification
   - Confirm security checklist satisfied

---

### Agent 2: OpenAI Agent Orchestrator

The OpenAI Agent Orchestrator agent parses natural language commands, chains MCP tools together intelligently, and manages conversation context. It is supported by three specialized skills:

#### **1. Natural Language Parsing & Intent Recognition Skill**
- **Location**: `.claude/skills/natural-language-parsing/SKILL.md`
- **Owner**: openai-agent-orchestrator agent
- **Purpose**: Transform natural language user inputs to structured MCP tool operations with confidence scoring and ambiguity resolution
- **Key Capabilities**:
  - **Intent Classification**: 7 core intents (CREATE_TASK, LIST_TASKS, FILTER_TASKS, COMPLETE_TASK, DELETE_TASK, UPDATE_TASK, TASK_SUMMARY) with pattern matching
  - **Confidence Scoring**: Multi-factor algorithm (pattern matching 40%, semantic 30%, parameter extraction 20%, language quality 10%)
  - **Ambiguity Resolution**: Handles multiple intents with ranking, user clarification, and context-dependent reference lookup
  - **Edge Case Handling**: Typos (Levenshtein ≤ 2), slang normalization, multi-part commands, negation, context-dependent references
  - **Response Templates**: Multilingual (EN/UR) for confirmations, errors, and summaries
  - **Task Summary Aggregation**: Calculates total, completed, pending, by_priority, by_status with filtering
  - **Intent Testing**: 15+ test variations per intent (~100+ total scenarios)
  - **Multilingual NLU**: Language detection + localized patterns for English/Urdu
  - **Voice Preprocessing**: Foundation for Phase 3 bonus voice input feature
- **Usage Phase**: Intent recognition and command parsing; transforms user message to tool operations

#### **2. Tool Chaining & Multi-Step Orchestration Skill**
- **Location**: `.claude/skills/tool-chaining-orchestration/SKILL.md`
- **Owner**: openai-agent-orchestrator agent
- **Purpose**: Orchestrate multiple MCP tool invocations in sequence with data flow, error recovery, and timeout management
- **Key Capabilities**:
  - **4 Core Tool Chain Patterns**: FIND_AND_UPDATE, FIND_AND_DELETE, FIND_AND_COMPLETE, TASK_SUMMARY_GENERATION
  - **Data Flow Mapping**: Output extraction rules, type compatibility validation, transformation pipeline
  - **Error Taxonomy**: Client errors (invalid_task_id, malformed_input, permission_denied, auth_required), server errors (database_error, service_unavailable), rate limiting (429), timeouts (504)
  - **Retry Logic**: Exponential backoff (max_retries=3, delays=[100ms, 200ms, 400ms]), max_delay=1000ms, jitter to prevent thundering herd
  - **Idempotency Patterns**: Safe re-execution for complete_task, delete_task, update_task with idempotency keys (24hr TTL)
  - **Rate Limiting & Backpressure**: Per-user limits (add_task: 100/min, list_tasks: 500/min, delete_task: 50/min), circuit breaker, request queue
  - **Timeout Management**: Per-tool (2-3s), chain-level (7-8s), timeout escalation strategy (double on retry)
  - **Tool Composition Validation**: Precondition checking, compatibility verification, fallback strategies
  - **Error Recovery Responses**: User-friendly messages with actionable suggestions
  - **Execution Tracing**: Comprehensive logging with trace IDs for debugging
- **Usage Phase**: Multi-step operations; chains tools to achieve complex tasks with error recovery

#### **3. User Context & Conversation Management Skill**
- **Location**: `.claude/skills/user-context-conversation/SKILL.md`
- **Owner**: openai-agent-orchestrator agent
- **Purpose**: Manage user authentication, conversation state, and multi-turn history retrieval with JWT validation and user isolation
- **Key Capabilities**:
  - **JWT Extraction & Validation**: Authorization header parsing, signature verification (HS256), expiry checking, claim validation
  - **User Context Extraction**: user_id from token.sub, URL path matching, user_context object creation
  - **User Details Loading**: Query user preferences (language, timezone) from database with caching
  - **Conversation State Management**: New vs resumed conversation detection, ownership verification, stale conversation detection (30 days)
  - **Conversation History Retrieval**: Pagination (offset-based), chronological ordering (ASC), user_id filtering (CRITICAL), token estimation
  - **Context Window Optimization**: Token counting, history truncation, summarization for API limits (8K-128K tokens)
  - **Session Management**: Activity tracking (24hr timeout), concurrent sessions (max 5), logout strategies
  - **Agent Context Preparation**: System prompt injection with user preferences, message history ordering
  - **Multi-User Isolation**: ALL queries filtered by user_id (parameterized), conversation ownership verification, audit logging
  - **Error Recovery**: Handle token expiry, missing conversations, session timeouts gracefully
- **Usage Phase**: Pre-execution; authenticates user, loads context, prepares conversation history for agent

#### **OpenAI Agent Orchestrator Skills Integration Workflow**

The three skills work together in sequence during Phase 3 agent execution:

1. **Authentication & Context Phase** (Skill 3):
   - Validate JWT token and extract user_id
   - Load user preferences (language, timezone)
   - Retrieve conversation history
   - Prepare agent context with system prompt

2. **Intent Recognition Phase** (Skill 1):
   - Parse user message using intent classification
   - Score confidence for each potential intent
   - Resolve ambiguities if multiple intents qualify
   - Extract parameters for tool calls

3. **Orchestration Phase** (Skill 2):
   - Select appropriate tool chain for intent
   - Validate tool chain preconditions
   - Execute tools with data flow mapping
   - Handle errors with recovery strategies
   - Return results to user

4. **Response & Persistence Phase** (Skill 3 + all skills):
   - Format response using response templates
   - Store user message and agent response in database
   - Update conversation state
   - Return response to frontend

---

### Agent 3: FastAPI Chat Handler

The FastAPI Chat Handler agent implements the complete chat endpoint that bridges the OpenAI Agent Orchestrator with the backend database and HTTP clients. It is supported by three specialized skills:

#### **1. Chat Endpoint Implementation Skill**
- **Location**: `.claude/skills/chat-endpoint-implementation/SKILL.md`
- **Owner**: fastapi-chat-handler agent
- **Purpose**: Generate production-grade FastAPI POST endpoints with Pydantic validation, Agent SDK config, JWT auth, idempotency, transaction management, and pagination
- **Key Capabilities**:
  - **Pydantic Models**: ChatRequest (message + optional conversation_id), ChatResponse (with trace_id), ToolCallResponse, ChatErrorResponse
  - **Agent SDK Configuration**: MCP tool routing (6 tools), system prompts with language support, timeout management (30s agent, 10s per tool)
  - **JWT Authentication**: Token validation with HS256, user_id extraction, expiry checking
  - **Idempotency Management**: Redis cache with 24hr TTL for duplicate request detection
  - **Trace ID Tracking**: UUID generation, contextvars propagation, correlation logging
  - **Conversation History Pagination**: Limit/offset pagination (max 50), chronological ordering (oldest first)
  - **Token Counting**: tiktoken integration for GPT-4, 8K context limit with 500 token reserve
  - **Request Lifecycle**: 12-step flow from JWT validation to response persistence
- **Usage Phase**: Endpoint design and implementation; primary interface between HTTP clients and AI agent

#### **2. Conversation Persistence Management Skill**
- **Location**: `.claude/skills/conversation-persistence-management/SKILL.md`
- **Owner**: fastapi-chat-handler agent
- **Purpose**: Manage conversation and message persistence with SQLModel, atomic transactions, multi-user isolation, and race condition prevention
- **Key Capabilities**:
  - **SQLModel Schemas**: Conversation (id, user_id, created_at, updated_at) and Message (id, conversation_id, role, content, tool_calls, created_at)
  - **Atomic Message Storage**: store_user_message, store_ai_response with automatic rollback on failure
  - **History Retrieval**: Parameterized queries with user_id filtering, pagination, chronological ordering
  - **Token Estimation & Truncation**: tiktoken-based token counting, oldest-message removal preserving context
  - **Multi-User Isolation**: Parameterized queries (SQL injection prevention), ownership verification on all reads
  - **Race Condition Prevention**: Optimistic locking (version column) + Row-level locking (PostgreSQL FOR UPDATE)
  - **Connection Pool**: Neon PostgreSQL configuration (pool_size=5, max_overflow=10, pool_recycle=3600)
  - **Stale Conversation Detection**: 30-day threshold for archival detection
- **Usage Phase**: Database operations; message persistence and history retrieval with security guarantees

#### **3. Chat Error Handling & Recovery Skill**
- **Location**: `.claude/skills/chat-error-handling-recovery/SKILL.md`
- **Owner**: fastapi-chat-handler agent
- **Purpose**: Implement graceful error handling with comprehensive taxonomy, HTTP mapping, structured logging, multilingual messages, and recovery strategies
- **Key Capabilities**:
  - **Error Taxonomy**: 9 error categories (Auth, Authorization, Validation, Resource, Conflict, Rate Limit, Database, Agent, Timeout)
  - **HTTP Status Mapping**: 400 (validation), 401 (auth), 403 (authorization), 409 (conflict), 429 (rate limit), 500 (server), 504 (timeout)
  - **Structured Logging**: JSON logging with trace ID, user_id, conversation_id, IP address for correlation
  - **Error Messages**: Production messages (user-friendly) + Development messages (detailed troubleshooting)
  - **Multilingual Support**: 22+ error messages in English and Urdu for Phase 3 internationalization
  - **Retry Logic**: Exponential backoff (100ms → 200ms → 400ms, max 3 attempts) for transient failures
  - **Tool Failure Handling**: Partial success semantics (some tools fail, others succeed, return aggregated results)
  - **Security Audit Logging**: Breach detection, cross-user access attempts, IP tracking, rate limit violations
  - **Rate Limit Responses**: Retry-After header (429) with backoff guidance
- **Usage Phase**: Error handling and recovery; global middleware for consistent error responses

#### **FastAPI Chat Handler Skills Integration Workflow**

The three skills work together to implement complete chat endpoint functionality:

1. **Request Validation Phase** (Skill 1):
   - Parse and validate ChatRequest (Pydantic models)
   - Extract JWT token, validate expiration
   - Generate or validate idempotency key
   - Check duplicate requests via idempotency store

2. **Persistence Phase** (Skill 2):
   - Fetch conversation or create new
   - Retrieve conversation history with pagination
   - Truncate history to fit token limit
   - Store user message atomically

3. **Agent Execution Phase** (Skill 1):
   - Initialize Agent SDK with MCP tools
   - Build message array (system prompt + history + user message)
   - Execute agent with timeout protection
   - Capture tool calls and responses

4. **Response Persistence & Error Handling Phase** (Skills 2 + 3):
   - Store AI response with tool calls
   - Commit transaction (or rollback on failure)
   - Map errors to HTTP status codes
   - Log with trace ID for debugging
   - Return formatted response with trace ID

---

### Agent 4: TDD Phase 3 Enforcer

The TDD Phase 3 Enforcer agent ensures strict Test-Driven Development practices throughout Phase 3 development. It generates comprehensive failing tests before implementation, guides the Red-Green-Refactor cycle, and enforces mandatory coverage requirements. It is supported by three specialized skills:

#### **1. Chat Flow Testing Skill**
- **Location**: `.claude/skills/chat-flow-testing/SKILL.md`
- **Owner**: tdd-phase3-enforcer agent
- **Purpose**: End-to-end testing of FastAPI chat endpoints using direct HTTP requests with httpx + pytest
- **Key Capabilities**:
  - **HTTP Testing with httpx**: Async HTTP client sending direct POST requests to /api/{user_id}/chat endpoints (no browser automation)
  - **JWT Authentication Tests**: Valid tokens, missing tokens, expired tokens, invalid signatures, malformed bearer headers (5 scenarios)
  - **Authorization & User Isolation**: User A accessing own conversations, user B attempting to access user A's data, token/URL mismatches (3 scenarios)
  - **Conversation Lifecycle**: Create new conversations (201), resume existing (200), non-existent (403 to prevent enumeration)
  - **Message Validation**: Valid formats, empty messages, >5000 char limits, invalid UUIDs, missing required fields (5 scenarios)
  - **Idempotency**: Duplicate requests cached, different idempotency keys create new messages (2 scenarios)
  - **Response Format & Trace ID**: Schema validation, trace ID format (UUID), trace ID in headers (3 scenarios)
  - **Tool Execution**: tool_calls array structure, execution times, status codes
  - **Multi-Step Flows**: add → list → complete chains, history preservation across messages
  - **Status Code Coverage**: 201 created, 200 success, 400 validation errors, 401 auth, 403 forbidden, 404 resource not found, 500 server errors, 504 timeouts
  - **10 Comprehensive Test Sections** with 829 lines of examples and patterns
- **Usage Phase**: TDD Red phase; generates failing tests that define expected endpoint behavior before implementation

#### **2. MCP Tool Testing Skill**
- **Location**: `.claude/skills/mcp-tool-testing/SKILL.md`
- **Owner**: tdd-phase3-enforcer agent
- **Purpose**: Unit testing MCP tools (add_task, list_tasks, complete_task, delete_task, update_task, get_task_summary) using pytest + SQLModel fixtures
- **Key Capabilities**:
  - **SQLModel Fixtures with Rollback**: Automatic transaction rollback after each test for complete isolation
  - **Input Validation**: Title length constraints (min/max), priority enum (low/medium/high), special characters, pagination limits
  - **Authorization & User Isolation**: User A only sees user A's tasks, user B cannot access user A's tasks, cross-user prevention (critical)
  - **Constraint Violations**: Duplicate titles allowed (same user), NOT NULL constraint handling, unique constraint verification
  - **Concurrency Testing**: Optimistic locking version mismatch detection, race condition prevention
  - **Query Performance**: <100ms execution time validation for list_tasks with 100+ tasks
  - **Error Handling**: 25+ error codes tested, invalid format detection, non-existent task handling
  - **Tool Chaining**: add → list → complete sequences, add multiple → get summary aggregation
  - **Response Schema Validation**: Required fields, correct types (UUID for ID, ISO datetime for timestamps), user_id never exposed
  - **Edge Cases**: Empty lists, boundary values (exactly at limit, one more than limit), pagination edge cases
  - **10 Comprehensive Test Sections** with 692 lines of SQLModel patterns and fixture examples
- **Usage Phase**: TDD Red phase; generates failing unit tests for MCP tool implementations with database verification

#### **3. Agent Behavior Testing Skill**
- **Location**: `.claude/skills/agent-behavior-testing/SKILL.md`
- **Owner**: tdd-phase3-enforcer agent
- **Purpose**: Testing OpenAI Agent SDK behavior with mock MCP tools for intent recognition, parameter extraction, and tool selection
- **Key Capabilities**:
  - **Intent Recognition**: 7 core intents (add_task, list_tasks, complete_task, update_task, delete_task, get_summary, query_tasks) with 15+ variations each (100+ total test cases)
  - **Parameter Extraction**: Title extraction, priority classification (high/medium/low), status detection (pending/completed)
  - **Confidence Scoring**: High confidence >0.8, medium 0.5-0.8, low <0.5 with multi-factor algorithm
  - **Error Recovery**: Tool failures handled gracefully, retry logic with exponential backoff, fallback strategies
  - **Multi-User Isolation**: Agent never leaks other users' data, all tool calls filtered by user_id
  - **Conversation History**: Single-turn standalone commands, multi-turn context preservation, history usage validation
  - **Multilingual Support**: English + Urdu (Phase 3 bonus feature) intent recognition and response generation
  - **Response Generation**: Task summaries without technical details, user-friendly confirmations, error messages
  - **Tool Chaining**: add task → get summary sequences, find → update chains, find → delete operations
  - **Mock Tool Setup**: AsyncMock patterns for all 6 MCP tools without database dependencies
  - **100+ Test Cases** covering intent variations, edge cases, multilingual scenarios, error recovery
  - **9 Comprehensive Test Sections** with 745 lines of mock patterns and agent behavior examples
- **Usage Phase**: TDD Red phase; generates failing tests for agent NLP, intent recognition, and tool orchestration

#### **TDD Phase 3 Enforcer Skills Integration Workflow**

The three skills work together to enforce TDD discipline throughout Phase 3 development:

1. **Red Phase - Test Generation**:
   - Chat Flow Testing: Generate failing HTTP endpoint tests (10 sections, 829 lines)
   - MCP Tool Testing: Generate failing unit tests with database verification (10 sections, 692 lines)
   - Agent Behavior Testing: Generate failing agent behavior tests with mocks (9 sections, 745 lines)

2. **Green Phase - Implementation Guidance**:
   - Implement minimal code to make each failing test pass
   - Skills document expected signatures and patterns
   - Run tests iteratively (single test → multiple → all passing)

3. **Refactor Phase**:
   - Improve code quality while keeping all tests green
   - Extract reusable patterns from implementations
   - Maintain or improve test coverage percentages

4. **Coverage Enforcement**:
   - Chat flows: 100% coverage mandatory
   - Auth/security: 100% coverage mandatory
   - MCP tools: 90%+ coverage required
   - Agent behaviors: 80%+ coverage required
   - All coverage enforced through failing tests

---

### Agent 5: Phase 3 Compliance Reviewer

The Phase 3 Compliance Reviewer agent performs systematic audits of the Todo AI Chatbot implementation to ensure adherence to architectural principles, security requirements, and specification standards. It is supported by three specialized skills:

#### **1. Stateless Audit Skill**
- **Location**: `.claude/skills/stateless-audit/SKILL.md`
- **Owner**: phase3-compliance-reviewer agent
- **Purpose**: Scans for state leaks in the chat endpoint and MCP server with comprehensive verification
- **Responsibilities**:
  - **Memory State Audit**: Identifies in-memory session variables, request-scoped state, global state that could cause issues across requests
  - **Database State Verification**: Ensures all conversation state is properly persisted to Neon PostgreSQL with proper transaction handling
  - **Cache State Analysis**: Reviews caching mechanisms to ensure they don't store session-specific data inappropriately
  - **Atomic Operation Verification**: Confirms each request handles its own transaction lifecycle (create → execute → commit/rollback → close)
  - **Performance Impact Assessment**: Evaluates the performance implications of stateless patterns (connection pooling, query optimization)
  - **Automated Testing**: Provides test cases to verify statelessness (restart server, verify conversations persist, concurrent request handling)

#### **2. Integration Review Skill**
- **Location**: `.claude/skills/integration-review/SKILL.md`
- **Owner**: phase3-compliance-reviewer agent
- **Purpose**: Verifies Phase 2-3 seamlessness with comprehensive validation of integration points
- **Responsibilities**:
  - **API Contract Verification**: Ensures chat endpoints use same JWT validation as Phase 2, consistent error responses, matching data models
  - **Data Consistency Validation**: Verifies chatbot operates on same Task/User tables as Phase 2
  - **Security Boundary Validation**: Confirms all security measures (JWT validation, user_id matching, cross-user access prevention) work identically
  - **Model Consistency Check**: Validates that data models (Task, User) are consistent between Phase 2 frontend/backend and Phase 3 MCP tools
  - **Regression Testing**: Provides test scenarios to ensure Phase 2 functionality isn't broken by Phase 3 additions
  - **Endpoint Mapping Verification**: Confirms MCP tools map correctly to Phase 2 database operations

#### **3. Spec Refinement for Chat Skill**
- **Location**: `.claude/skills/spec-refinement-chat/SKILL.md`
- **Owner**: phase3-compliance-reviewer agent
- **Purpose**: Updates specs with comprehensive validation and expansion capabilities for chat features
- **Responsibilities**:
  - **Impact Analysis**: Assesses the impact of new features (Urdu parsing, voice input) on existing functionality
  - **Backward Compatibility**: Ensures new features don't break existing chat flows or MCP tool contracts
  - **Feature Completeness**: Validates that new features (Basic Level tasks via natural language) are fully specified with examples
  - **Natural Language Coverage**: Ensures examples cover all 7 core intents (add_task, list_tasks, complete_task, delete_task, update_task, get_summary, query_tasks) with variations
  - **Bonus Feature Integration**: Properly specifies Urdu language support and voice input handling with proper preprocessing
  - **Consistency Verification**: Checks that new specifications align with existing Phase 2 and Phase 3 patterns

#### **Phase 3 Compliance Reviewer Skills Integration Workflow**

The three skills work together to ensure comprehensive compliance validation throughout Phase 3 development:

1. **Stateless Audit Phase** (Skill 1):
   - Scan codebase for potential state leaks
   - Identify any session variables or request-scoped state
   - Validate all conversation state is persisted to database
   - Confirm atomic operation boundaries
   - Assess impact of stateless patterns
   - Document findings with remediation suggestions

2. **Integration Validation Phase** (Skill 2):
   - Compare API endpoints with Phase 2 patterns
   - Trace data paths between Phase 2 and Phase 3
   - Validate consistent security measures
   - Compare data models across phases
   - Execute tests to ensure Phase 2 functionality intact
   - Verify MCP tool to database operation mappings

3. **Specification Quality Phase** (Skill 3):
   - Evaluate new feature impacts
   - Test backward compatibility
   - Validate full feature specification
   - Ensure comprehensive intent examples
   - Verify bonus feature specifications
   - Check alignment with existing patterns

4. **Compliance Certification Phase** (All Skills):
   - Generate comprehensive compliance reports
   - Validate all mandatory compliance requirements
   - Issue compliance certificate for deployment approval
   - Document remediation recommendations for non-compliance issues

---

## Code Quality Standards

### TypeScript (Frontend)
- **Strict Mode**: `"strict": true` in tsconfig.json
- **No Any**: Avoid `any` type; use `unknown` or proper types
- **Interfaces**: Define interfaces for all props, API responses, state
- **Error Handling**: Typed error boundaries and try-catch blocks

### Python (Backend)
- **Type Hints**: 100% coverage (Mypy strict mode)
- **Pydantic**: Use for request/response validation
- **SQLModel**: Type-safe ORM queries
- **Ruff**: Linting + formatting (auto-fix on save)

### Testing Requirements (TDD - MANDATORY)

**Test-Driven Development Process:**
1. **Red**: Write failing test first
2. **Green**: Write minimal code to pass test
3. **Refactor**: Improve code while keeping tests green

**Backend Testing (pytest):**
- **Unit Tests**: 80%+ overall coverage, 100% for auth/security
- **Integration Tests**: All API endpoints with auth scenarios
- **Security Tests**: User isolation, SQL injection, XSS (MANDATORY)
- **Performance Tests**: JWT verification < 10ms, Task list < 200ms
- **Test Specs**: See `@specs/testing/backend-testing.md`

**Frontend Testing (Vitest + React Testing Library):**
- **Component Tests**: 70%+ overall coverage, 90%+ for auth/task components
- **Unit Tests**: API client functions, utilities, hooks
- **Accessibility Tests**: Keyboard navigation, screen reader labels
- **Test Specs**: See `@specs/testing/frontend-testing.md`

**E2E Testing (Playwright):**
- **Critical Flows**: 100% coverage (signup, login, create task, complete, logout)
- **Cross-Browser**: Chrome, Firefox, Safari
- **Performance**: Page load < 2s, task list load < 500ms
- **Test Specs**: See `@specs/testing/e2e-testing.md`

**Testing Philosophy**: See `@specs/testing/overview.md` for complete testing strategy

---

## Development Workflow

### Spec-Driven Iteration Cycle
```
1. /sp.specify    → Write feature specification
2. /sp.clarify    → Ask 2-5 targeted questions to eliminate ambiguity
3. /sp.plan       → Create architecture plan (tech decisions, API contracts)
4. /sp.tasks      → Break down into atomic, testable tasks
5. /sp.analyze    → Cross-check spec/plan/tasks for consistency
6. /sp.implement  → Generate code via Claude Code
7. Test & Verify  → Run tests, check security, validate UI
8. Iterate        → If issues found, refine spec (NOT code) and regenerate
```

### Prompt History Records (PHRs)
- **Creation**: After EVERY user interaction (automatic)
- **Location**: `history/prompts/{feature-name}/`
- **Naming**: `{ID}-{slug}.{stage}.prompt.md`
- **Required Fields**: ID, title, stage, date, user input (verbatim), AI response

### Architecture Decision Records (ADRs)
- **Trigger**: Significant architectural decisions (framework choice, auth strategy, DB schema)
- **Process**: Suggest ADR creation; wait for user consent
- **Location**: `history/adr/`
- **Template**: Use `.specify/templates/adr-template.md`

---

## Constraints

### Prohibited Actions
- ❌ Manual code writing or editing
- ❌ Inline styles (use Tailwind classes only)
- ❌ Hardcoded secrets (use environment variables)
- ❌ Refactoring unrelated code
- ❌ Skipping spec/plan/tasks stages

### Required Actions
- ✅ Use Context7 MCP for tech documentation
- ✅ Create PHRs for all interactions
- ✅ Write specs BEFORE code generation
- ✅ Test user isolation security
- ✅ Deploy to Vercel/Hugging Face

### Platform Requirements
- **Windows Users**: MUST develop in WSL 2
- **Local Development**: docker-compose or separate dev servers
- **Environment Files**: `.env.local` (frontend), `.env` (backend) with templates in repo

---

## Success Criteria

### Functional Requirements
- ✅ Fully working multi-user web app
- ✅ All Basic, Intermediate, and Advanced features implemented
- ✅ Secure authentication with JWT
- ✅ Persistent storage in Neon PostgreSQL
- ✅ Responsive UI with animations
- ✅ Browser notifications for reminders

### Security Requirements
- ✅ User isolation verified (no cross-user access)
- ✅ JWT token validation on all protected endpoints
- ✅ Unauthorized requests return 401
- ✅ Passwords hashed (never stored plaintext)
- ✅ SQL injection prevented (parameterized queries)

### Documentation Requirements
- ✅ Complete specs folder with refinement history
- ✅ PHRs demonstrating spec-driven process
- ✅ ADRs for major architectural decisions
- ✅ README with setup instructions
- ✅ API documentation (OpenAPI/Swagger)

### Deployment Requirements
- ✅ Frontend deployed to Vercel or GitHub Pages
- ✅ Backend API deployed to Hugging Face Spaces
- ✅ Database hosted on Neon (serverless PostgreSQL)
- ✅ Environment variables configured in deployment platforms
- ✅ Live demo URL accessible

### Hackathon Judging Criteria

**Phase 2:**
- ✅ Clear evidence of spec-driven process (specs, PHRs, iterations)
- ✅ No manual code editing (all AI-generated)
- ✅ Security best practices demonstrated
- ✅ Modern, polished UI/UX
- ✅ Ready for Phase III progression (AI chatbot integration)

**Phase 3:**
- ✅ AI chatbot conversationally manages Basic Level features
- ✅ MCP server with stateless architecture
- ✅ Full integration with Phase 2 data and security
- ✅ 100% test coverage for chat flows and security
- ✅ Pure spec-driven implementation (zero manual code)
- ✅ Ready for Phase IV progression (Kubernetes deployment)

---

## Governance & Versioning

This constitution supersedes all other development practices and guidelines. ALL team members (human architects and AI agents) MUST adhere to these principles.

### Amendment Process

**Requirements for Constitution Changes:**
- Document rationale in Architecture Decision Record (ADR)
- Clear justification (architectural significance, not convenience)
- Explicit user approval via `/sp.constitution` command
- Migration plan for affected code/specs
- Update version number per semantic versioning

### Version Strategy

**Semantic Versioning:** MAJOR.MINOR.PATCH

- **MAJOR**: Backward-incompatible principle changes or removals (Phase 4+)
- **MINOR**: New principle added, significant expansion, or Phase progression
- **PATCH**: Clarifications, wording fixes, non-semantic refinements

**Examples:**
- 1.0.0 → 1.1.0: Add Phase 3 (new phase, expanded principles)
- 1.1.0 → 1.1.1: Clarify MCP tool parameter names (wording only)
- 1.1.0 → 2.0.0: Remove TDD requirement (major change)

### Enforcement

- All PRs/reviews verify compliance with current version
- Complexity/exceptions require documented justification
- Use `CLAUDE.md` files (root, frontend, backend, phase-3 if needed) for runtime development guidance
- PHRs track all significant decisions and iterations

### Review Schedule

- **Before Phase IV Initiation**: Next major review
- **Quarterly**: Minor updates and clarifications
- **As-needed**: Amendment via `/sp.constitution` for new phases

---

## Sync Impact Report

**Amendment Version**: 1.1.0 → 1.2.0

**Rationale**: Emphasis on stateless architecture requirements and clearer architectural constraints for Phase 3 (AI Chatbot Integration), with specific emphasis on the server being stateless and all conversation state persisted to database.

**Modified/Added Principles:**
- ✅ X. AI Chatbot Integration: Enhanced emphasis on stateless server architecture requirement

**New Major Sections:**
- None added

**Templates Requiring Updates:**
- ✅ `@specs/templates/spec-template.md` - May need Phase 3 chatbot updates
- ✅ `@specs/templates/plan-template.md` - May need MCP architecture updates

**Follow-up Tasks:**
- Create Phase 3 specification files in `specs/features/ai-chatbot/`
- Create MCP tools specification in `specs/api/mcp-tools.md`
- Update CLAUDE.md files to reference Phase 3 workflows
- Create Phase 3 database migration scripts
- Create Phase 3 API testing specifications

---

## Governance & Versioning (Continued)

**Version**: 1.2.0
**Ratified**: 2026-01-02 (Phase 2)
**Last Amended**: 2026-01-16 (Phase 3 Statelessness Emphasis)
**Amendment Type**: MINOR (Enhanced Phase 3 requirements)
**Next Review**: Before Phase IV initiation
**Status**: Active for Phase 2 + Phase 3 development