<!-- SYNC IMPACT REPORT -->
<!-- Version Change: 1.2.0 → 1.3.0 -->
<!-- Modified Principles: Added Phase 4 DevOps and Kubernetes deployment principles -->
<!-- Added Sections: Phase 4: Local Kubernetes Deployment, DevOps Standards, Containerization Requirements -->
<!-- Removed Sections: None -->
<!-- Templates Requiring Updates: ✅ @specs/templates/spec-template.md, ✅ @specs/templates/plan-template.md, ⚠ @specs/templates/tasks-template.md -->
<!-- Deferred Placeholders: None -->

# Hackathon II: Todo Full-Stack Web Application Constitution

**Project**: Multi-user Full-Stack Todo Web Application with AI Chatbot and Local Kubernetes Deployment
**Phases**: Phase 2 of 5 (Full-Stack Web Application) + Phase 3 of 5 (AI Chatbot Integration) + Phase 4 of 5 (Local Kubernetes Deployment)
**Development Methodology**: Strict Spec-Driven Development (SDD) with Claude Code + Spec-Kit Plus + AI-Assisted DevOps

---

## Table of Contents

- [Core Principles](#core-principles)
- [Phase 2: Full-Stack Web App](#phase-2-full-stack-web-app)
- [Phase 3: Todo AI Chatbot](#phase-3-todo-ai-chatbot)
- [Phase 4: Local Kubernetes Deployment](#phase-4-local-kubernetes-deployment)
- [DevOps & Containerization Standards](#devops--containerization-standards)
- [Technology Stack](#technology-stack)
- [Governance & Versioning](#governance--versioning)

---

## Core Principles

### I. Strict Spec-Driven Development (NON-NEGOTIABLE)

Every feature, component, API endpoint, database schema, and configuration change MUST begin with a detailed Markdown specification:

- **Specification First**: No code is written until specs are approved
- **Iterative Refinement**: Refine specs through multiple iterations until Claude Code generates correct, complete implementation
- **Complete Documentation**: All specs must include user stories, acceptance criteria, edge cases, error handling, and test scenarios
- **AI as Implementer**: Claude Code handles ALL syntax, boilerplate, and implementation details

**Workflow**: `/sp.specify → /sp.clarify → /sp.plan → /sp.tasks → /sp.analyze → /sp.implement`

### II. No Manual Coding Allowed (NON-NEGOTIABLE)

ALL code (frontend, backend, database, config, tests, infrastructure) MUST be generated by Claude Code:

- **Zero Manual Edits**: Manual code writing or editing is strictly prohibited
- **Fix via Specs**: Issues are resolved by improving specifications and re-generating code
- **Human as Architect**: Developer role is limited to system architect—write/refine specs, plans, and prompts
- **AI Handles Implementation**: Claude Code generates all syntax, patterns, and boilerplate

**Rationale**: Ensures consistency, maintainability, and demonstrates pure spec-driven methodology for hackathon judging.

### III. Test-Driven Development (TDD) - NON-NEGOTIABLE

ALL code must be developed using strict Test-Driven Development with Red-Green-Refactor cycle:

- **Red**: Write failing test FIRST (defines expected behavior)
- **Green**: Write minimal code to make test pass
- **Refactor**: Improve code quality while keeping tests green
- **No Code Without Tests**: Production code is written ONLY after failing test exists

**TDD Workflow**: `/sp.specify → /sp.plan → /sp.tasks → /sp.red → /sp.green → /sp.refactor`

**Testing Requirements:**
- **Backend**: 80%+ overall coverage, 100% for authentication and security
- **Frontend**: 70%+ overall coverage, 90%+ for critical components
- **E2E**: 100% coverage for critical user flows
- **Security Tests**: MANDATORY (user isolation, SQL injection, XSS)
- **Kubernetes Tests**: 100% coverage for deployment, scaling, and health checks

**Test Specifications**: See `@specs/testing/` for complete testing requirements

### IV. Use Subagents and Skills

- **Explore Agent**: Use for codebase exploration and understanding (`subagent_type=Explore`)
- **Plan Agent**: Use for architecture and design decisions (`subagent_type=Plan`)
- **Skills**: Leverage `/sp.*` skills for spec-driven workflows
- **Task Agent**: Use for complex multi-step operations (`subagent_type=general-purpose`)
- **Containerization Agent**: Use for Docker containerization tasks (`subagent_type=containerization-specialist`)
- **Helm Chart Agent**: Use for Helm chart generation (`subagent_type=helm-chart-packager`)
- **Kubernetes Operations Agent**: Use for K8s operations (`subagent_type=k8s-ops-orchestrator`)
- **Blueprint Generator Agent**: Use for cloud-native blueprint creation (`subagent_type=blueprint-generator`)

### V. Context7 MCP Server for Documentation

- **Mandatory Documentation Lookup**: Before using any technology, library, or framework, MUST read official documentation using Context7 MCP server
- **Technologies Requiring Lookup**:
  - Next.js 15+ (App Router)
  - FastAPI
  - SQLModel
  - Better Auth
  - Neon PostgreSQL
  - shadcn/ui
  - GSAP & Framer Motion
  - OpenAI Agents SDK (Phase 3)
  - Official MCP SDK (Phase 3)
  - OpenAI ChatKit (Phase 3)
  - Docker & Containerization
  - Kubernetes & Helm
  - kubectl-ai and kagent
- **Pattern**: `mcp__context7__resolve-library-id` → `mcp__context7__query-docs`

### VI. User Data Isolation & Security (CRITICAL)

Multi-user support with absolute user isolation:

- **Ownership Enforcement**: Every task belongs to exactly one user (enforced at database level)
- **Authorization Checks**: ALL API endpoints verify JWT token and user_id matching
- **No Cross-User Access**: Users CANNOT view, modify, or delete other users' tasks
- **Security Testing**: Test plans must include unauthorized access attempts (MANDATORY)
- **Fail-Secure**: Invalid/missing tokens → 401 Unauthorized
- **Test Coverage**: 100% coverage required for all security-related code

### VII. Model Context Protocol (MCP) - Phase 3 CRITICAL

MCP provides standardized interfaces for AI agents to interact with task management:

- **MCP Server Architecture**: Stateless MCP server exposes task operations as tools
- **Tool-Based Operations**: All task modifications via MCP tools (add_task, list_tasks, complete_task, delete_task, update_task)
- **Stateless Design**: Server maintains NO state; all conversation/task state persisted to database
- **Tool Parameters**: All tools include required `user_id` parameter for security isolation
- **Tool Returns**: Standardized response format with operation status and affected task details
- **Error Handling**: Tools gracefully handle "task not found" and other errors with descriptive messages
- **Security**: MCP tools enforce same JWT + user_id validation as REST API endpoints

**MCP Tools Specification:**
- `add_task(user_id, title, description)` → Returns task_id, status, title
- `list_tasks(user_id, status="all"|"pending"|"completed")` → Returns array of task objects
- `complete_task(user_id, task_id)` → Returns task_id, status, title
- `delete_task(user_id, task_id)` → Returns task_id, status, title
- `update_task(user_id, task_id, title, description)` → Returns task_id, status, title

### VIII. Modular & Future-Ready Design

Build with clean architecture for easy evolution into future phases:

- **Phase III Ready**: AI chatbot integration with MCP tools
- **Phase IV Ready**: Kubernetes deployment structure with containerization
- **Phase V Ready**: Event-driven architecture patterns
- **Clean Separation**: Frontend ↔ API ↔ Business Logic ↔ Data Layer ↔ MCP Server ↔ Kubernetes
- **Versioned APIs**: API versioning strategy for backward compatibility
- **Cloud-Native Patterns**: Container-first design, 12-factor app principles, declarative infrastructure

### IX. Design Excellence (CRITICAL)

**Dashboard-Like Experience**: Build a modern, professional dashboard interface with fantastic UX that rivals premium SaaS applications.

**UI/UX Requirements**:
- **Dashboard Layout**: Sidebar navigation, main content area with cards/panels, header with user profile
- **Visual Hierarchy**: Clear information architecture with proper spacing, grouping, and visual weight
- **Typography**: Use `JetBrains Mono` (code/monospace) and `Inter` (body text) fonts for premium feel
- **Glassmorphism**: Apply backdrop-blur effects for depth, layering, and modern aesthetic
- **Component Library**: Use shadcn/ui for consistent, accessible, production-ready components
- **No Inline Styles**: ALL styling via Tailwind CSS classes (maintainability and consistency)
- **Smooth Animations**: GSAP and Framer Motion for delightful micro-interactions and page transitions
- **Responsive Design**: Mobile-first approach with seamless breakpoints for tablet/desktop
- **Dark Mode Support**: Toggle between light/dark themes with smooth transitions
- **Interactive Feedback**: Hover states, loading skeletons, toast notifications, confirmation modals
- **Data Visualization**: Progress indicators, task completion stats, priority distributions
- **Intuitive Navigation**: Keyboard shortcuts, breadcrumbs, search with instant results
- **Performance**: 60fps animations, optimized images, lazy loading, minimal layout shifts

**UX Excellence Standards**:
- Every interaction should feel instant and responsive
- Zero confusion - users should intuitively understand how to complete tasks
- Delight users with subtle animations and polished details
- Accessibility first - WCAG 2.1 AA compliance minimum
- Error states that guide users to resolution
- Empty states that encourage action

**UI/UX Specifications**: See `@specs/ui/` for comprehensive design system documentation:
- `@specs/ui/design-system.md` - Complete design tokens (colors, typography, spacing, shadows, glassmorphism)
- `@specs/ui/dashboard-layout.md` - Layout structure for desktop, tablet, mobile (sidebar, header, content)
- `@specs/ui/glassmorphism.md` - Glassmorphism patterns and implementation (backdrop-blur, layering, depth)
- `@specs/ui/animations.md` - GSAP & Framer Motion specifications (60fps micro-interactions, transitions)
- `@specs/ui/responsive-design.md` - Mobile-first responsive patterns (breakpoints, touch targets, adaptive layouts)
- `@specs/ui/dark-mode.md` - Theme toggle implementation (next-themes, color variables, smooth transitions)
- `@specs/ui/accessibility.md` - WCAG 2.1 AA compliance (keyboard nav, screen readers, ARIA, color contrast)

### X. AI Chatbot Integration (Phase 3 Specific)

Phase 3 extends Phase 2 with conversational AI for task management:

- **Conversational Interface**: Natural language task creation, queries, and management
- **Stateless Server Architecture**: All conversation state persisted to database; server maintains no state between requests
- **MCP Tool Integration**: AI agent uses MCP tools for all task operations (no direct database access)
- **User Authentication Required**: Chatbot access requires valid JWT token; inherits Phase 2 security model
- **Task Summary on Login**: Chatbot provides task overview (total tasks, completed, pending, priorities) from logged-in user data
- **Theme Consistency**: Chatbot UI color/theme matches Phase 2 app (same design system, dark mode support)
- **Basic Features Only**: Phase 3 focuses on Basic Level features via natural language (Level 2/3 features in future phases)

### XI. AI-Assisted DevOps & Infrastructure as Code (Phase 4 Specific)

Phase 4 introduces cloud-native deployment with AI-assisted operations:

- **Containerization First**: Both Next.js frontend and FastAPI backend must be containerized with optimized Dockerfiles
- **Kubernetes Native**: Deploy to Minikube locally using industry-standard practices
- **Helm Charts**: Package applications using Helm for configuration management and deployment
- **Declarative Infrastructure**: All infrastructure defined in code with version control
- **AI-Assisted Operations**: Leverage Gordon for Docker, kubectl-ai and kagent for Kubernetes operations
- **Reusable Intelligence**: Implement subagents and skills for modular, reusable DevOps tasks
- **Cloud-Native Blueprints**: Develop blueprints powered by Claude Code Agent Skills for infrastructure automation
- **Local Deployment Only**: Target Minikube for Phase 4 (production cloud deployment reserved for Phase V)
- **Compatibility Assurance**: Maintain compatibility with Neon DB and authentication from prior phases

---

## Phase 2: Full-Stack Web App

### Overview

Phase 2 establishes the foundation: multi-user task management with persistent storage, JWT authentication, and polished UI/UX.

---

## Phase 3: Todo AI Chatbot

### Overview

Phase 3 extends Phase 2 by adding conversational AI for natural language task management. Users can interact with their tasks through a chat interface powered by OpenAI Agents SDK and MCP tools.

---

## Phase 4: Local Kubernetes Deployment

### Overview

Phase 4 transforms the application into a cloud-native architecture with containerization, orchestration, and AI-assisted operations. The Todo Chatbot is deployed to Minikube using industry-standard Kubernetes practices.

### Core DevOps Principles

| Principle | Description |
|-----------|-------------|
| **Containerization** | Next.js frontend and FastAPI backend packaged in optimized containers |
| **Infrastructure as Code** | All deployment configurations managed through Git |
| **Declarative Deployments** | Kubernetes manifests define desired state |
| **Helm Packaging** | Applications packaged with configurable parameters |
| **Service Discovery** | Internal communication via Kubernetes DNS |
| **Config Management** | Secrets and configmaps for environment-specific values |
| **Health Monitoring** | Readiness/liveness probes for reliability |
| **Auto-scaling** | Horizontal Pod Autoscaler based on demand |

### Deployment Architecture

| Component | Purpose | Deployment Strategy |
|-----------|---------|-------------------|
| **Frontend** | Next.js application | Deployment with rolling updates |
| **Backend** | FastAPI API server | Deployment with service mesh |
| **MCP Server** | AI chatbot MCP tools | StatefulSet if state required |
| **Database** | Neon PostgreSQL connection | External service reference |
| **Load Balancer** | Traffic distribution | Service type LoadBalancer |
| **Ingress** | External access routing | Ingress controller |
| **Monitoring** | Health and metrics | Prometheus/Grafana stack |

### AI-Assisted Operations

| Operation | AI Tool | Purpose |
|-----------|---------|---------|
| **Container Build** | Gordon | Automated Docker image creation |
| **K8s Commands** | kubectl-ai | Natural language Kubernetes operations |
| **Cluster Analysis** | kagent | Health monitoring and troubleshooting |
| **Scaling** | kubectl-ai | Dynamic resource adjustment |
| **Troubleshooting** | kagent | Automated issue detection |
| **Deployment** | Helm + AI | Intelligent release management |

---

## DevOps & Containerization Standards

### Containerization Requirements

#### Frontend Container (Next.js)
- **Base Image**: node:18-alpine or newer LTS version
- **Multi-stage Build**: Separate build and runtime stages
- **Layer Caching**: Optimize Docker layers for faster builds
- **Security**: Non-root user execution, minimal attack surface
- **Environment Variables**: Configurable via environment
- **Health Checks**: HTTP-based liveness/readiness probes
- **Resource Limits**: CPU and memory constraints defined

#### Backend Container (FastAPI)
- **Base Image**: python:3.13-slim or newer stable version
- **Dependencies**: Install via requirements.txt in separate layer
- **UV Package Manager**: Use UV for faster Python dependency installation
- **Security**: Non-root user execution, minimal packages
- **Environment Variables**: Database URLs, API keys, etc.
- **Health Checks**: Health endpoints for readiness/liveness
- **Resource Limits**: Defined CPU and memory constraints

### Kubernetes Manifest Standards

#### Namespace Strategy
- **Application Namespace**: Dedicated namespace for all app components
- **Resource Quotas**: Defined limits per namespace
- **Network Policies**: Isolate traffic between namespaces
- **RBAC**: Role-based access control for services

#### Deployment Best Practices
- **Replica Counts**: Minimum 2 for high availability
- **Rolling Updates**: Zero-downtime deployment strategy
- **Resource Requests/Limits**: Defined for predictable performance
- **Node Affinity**: Scheduling constraints if needed
- **Tolerations**: Handle tainted nodes appropriately

#### Service Configuration
- **ClusterIP Services**: Internal communication
- **LoadBalancer Services**: External access (Minikube compatible)
- **Headless Services**: For StatefulSets if needed
- **Service Discovery**: Via Kubernetes DNS

#### Ingress Configuration
- **TLS Termination**: SSL/TLS for secure connections
- **Path-based Routing**: Route to appropriate services
- **Rate Limiting**: Protect against abuse
- **Rewrite Rules**: URL manipulation if needed

### Helm Chart Structure

```
helm/
├── todo-chatbot/
│   ├── Chart.yaml          # Chart metadata
│   ├── values.yaml         # Default configuration
│   ├── values.schema.json  # Values validation schema
│   ├── templates/
│   │   ├── NOTES.txt              # Post-installation notes
│   │   ├── _helpers.tpl           # Template helpers
│   │   ├── frontend-deployment.yaml
│   │   ├── frontend-service.yaml
│   │   ├── backend-deployment.yaml
│   │   ├── backend-service.yaml
│   │   ├── mcp-deployment.yaml
│   │   ├── mcp-service.yaml
│   │   ├── ingress.yaml
│   │   ├── configmap.yaml
│   │   ├── secret.yaml
│   │   └── hpa.yaml              # Horizontal Pod Autoscaler
│   └── charts/                    # Dependency charts
```

### CI/CD Pipeline Standards

#### Build Process
1. **Code Validation**: Syntax and security scanning
2. **Docker Build**: Multi-stage optimized builds
3. **Image Scanning**: Vulnerability assessment
4. **Helm Lint**: Chart validation
5. **Test Execution**: Unit, integration, and E2E tests

#### Deployment Process
1. **Environment Validation**: Pre-deployment checks
2. **Helm Upgrade**: Deploy with rollback capability
3. **Health Verification**: Post-deployment validation
4. **Traffic Switching**: Gradual traffic shift if needed
5. **Rollback Capability**: Automated rollback on failure

---

## Technology Stack

### Phase 2 Stack

#### Frontend
- **Framework**: Next.js 15+ with App Router
- **Language**: TypeScript (strict mode)
- **Styling**: Tailwind CSS (no inline styles)
- **Components**: shadcn/ui
- **Animations**: GSAP + Framer Motion
- **Fonts**: JetBrains Mono, Inter
- **Design**: Glassmorphism (backdrop-blur effects)

#### Backend
- **Language**: Python 3.13+
- **Package Manager**: UV
- **Framework**: FastAPI
- **ORM**: SQLModel
- **Database**: Neon Serverless PostgreSQL
- **Authentication**: Better Auth with JWT tokens

### Phase 3 AI Stack

- **Frontend Chat UI**: OpenAI ChatKit (hosted)
- **AI Framework**: OpenAI Agents SDK
- **MCP Implementation**: Official MCP SDK
- **LLM Provider**: OpenAI API (GPT-4 or later)
- **Integration Pattern**: Stateless FastAPI endpoint + MCP server with database persistence

### Phase 4 DevOps Stack

- **Container Runtime**: Docker
- **Orchestration**: Kubernetes
- **Local Cluster**: Minikube
- **Packaging**: Helm
- **CI/CD**: AI-assisted with Claude Code
- **Monitoring**: Prometheus, Grafana (planned for production)
- **Logging**: Structured logging with correlation IDs

### Development Tools
- **AI Development**: Claude Code (Sonnet 4.5)
- **Spec Framework**: Spec-Kit Plus
- **Version Control**: Git
- **Environment**: WSL 2 (for Windows users)
- **AI DevOps Tools**: Gordon, kubectl-ai, kagent

### Deployment
- **Frontend (Phase 2)**: Vercel or GitHub Pages
- **Backend (Phase 2)**: Hugging Face Spaces
- **Chatbot UI (Phase 3)**: OpenAI ChatKit (hosted)
- **MCP Server (Phase 3)**: FastAPI endpoint on Hugging Face Spaces
- **Database**: Neon (serverless PostgreSQL, shared with Phase 2)
- **Phase 4 Target**: Minikube (local Kubernetes cluster)

---

## API Design Standards

### Base URL Structure
All API endpoints follow user-scoped pattern:
```
/api/{user_id}/...
```

### Required Endpoints

| Method | Endpoint | Description | Auth Required |
|--------|----------|-------------|---------------|
| GET | `/api/{user_id}/tasks` | List user's tasks (with filters/sort) | ✓ |
| POST | `/api/{user_id}/tasks` | Create new task | ✓ |
| GET | `/api/{user_id}/tasks/{id}` | Get task details | ✓ |
| PUT | `/api/{user_id}/tasks/{id}` | Update task | ✓ |
| DELETE | `/api/{user_id}/tasks/{id}` | Delete task | ✓ |
| PATCH | `/api/{user_id}/tasks/{id}/complete` | Toggle completion | ✓ |

### Authentication Flow
1. **JWT Tokens**: Better Auth configured for JWT issuance
2. **Token Secret**: Shared secret via `BETTER_AUTH_SECRET` env var
3. **Authorization Header**: `Authorization: Bearer <token>`
4. **Token Verification**: Backend middleware validates JWT on every request
5. **User ID Enforcement**: Middleware extracts `user_id` from token, verifies match with URL param
6. **Token Expiry**: 7 days (configurable)
7. **Unauthorized Response**: 401 with clear error message

### Phase 3 Chat API Endpoints

| Method | Endpoint | Description | Auth Required |
|--------|----------|-------------|---------------|
| POST | `/api/{user_id}/chat` | Send message & get AI response | ✓ |

**Chat Request:**
```json
{
  "conversation_id": "optional-uuid-or-null",
  "message": "Add a task to buy groceries"
}
```

**Chat Response:**
```json
{
  "conversation_id": "uuid",
  "response": "I've added 'Buy groceries' to your tasks.",
  "tool_calls": [
    {
      "tool": "add_task",
      "parameters": {"user_id": "xyz", "title": "Buy groceries", "description": null},
      "result": {"task_id": 5, "status": "created", "title": "Buy groceries"}
    }
  ]
}
```

**Chat Flow (Stateless, Database-Persisted State):**
1. Receive user message + optional conversation_id
2. Fetch conversation history from database (if conversation_id provided)
3. Build message array for AI agent (history + new message)
4. Store user message in Conversation.messages
5. Execute agent with MCP tools (agent calls tools as needed)
6. Store assistant response in Conversation.messages
7. Return response + tool invocations to client
8. Server maintains NO state (horizontally scalable)

---

## Feature Implementation Levels

### Level 1: Basic CRUD (Foundation)
- **Add Task**: Create with title and description
- **View Tasks**: List all user's tasks
- **Update Task**: Modify title/description
- **Delete Task**: Remove task (with confirmation)
- **Mark Complete**: Toggle task completion status

### Level 2: Intermediate Features (Organization)
- **Priority Levels**: HIGH (Red), MEDIUM (Yellow), LOW (Green), NONE
- **Tags/Categories**: Multi-tag support (comma-separated, max 20 chars each)
- **Search**: Keyword search across title/description (case-insensitive)
- **Filter**: By status (todo/done), priority, or tags (ANY-match logic)
- **Sort**: By Priority, Created Date, Title, or Due Date (with secondary sorting)

### Level 3: Advanced Features (Intelligence)
- **Recurring Tasks**: DAILY, WEEKLY, MONTHLY patterns
  - Auto-reschedule on completion or due date passage
  - Edge case handling (Feb 29, month-end dates)
- **Due Dates & Times**: DateTime precision (YYYY-MM-DD HH:MM)
  - Future validation
  - Browser notifications for due-soon tasks
- **Smart Reminders**:
  - Overdue detection (tasks past due datetime)
  - Due Soon alerts (within 60 minutes)
  - Browser notification API integration

---

## Database Schema (Phase 2 + Phase 3)

### Phase 2 Core Tables

| Table | Columns | Purpose |
|-------|---------|---------|
| **users** | id (UUID), email (unique), password_hash, name, created_at, updated_at, email_verified | User accounts |
| **tasks** | id (UUID), user_id (FK), title, description, completed, priority, tags (array), due_date, is_recurring, recurrence_pattern, created_at, updated_at, completed_at | Todo items |

### Phase 3 Extension Tables

| Table | Columns | Purpose |
|-------|---------|---------|
| **conversations** | id (UUID), user_id (FK), created_at, updated_at | Chat sessions (one per conversation thread) |
| **messages** | id (UUID), user_id (FK), conversation_id (FK), role (enum: "user"|"assistant"), content (text), created_at | Chat history (immutable, indexed by conversation_id) |

**Key Design Decisions:**
- Conversations table enables session resumption (user can continue conversation from previous session)
- Messages table maintains complete history for context (AI agent pulls conversation history for context)
- Both tables include user_id for efficient filtering and security isolation
- Messages are immutable (no updates/deletes, only appends)
- Indexes on (user_id, conversation_id) for fast history retrieval

---

## Monorepo Structure

```
Phase04_LocalKubernetesDeployment/
├── .specify/                    # Spec-Kit Plus framework
│   ├── config.yaml             # Monorepo configuration
│   ├── memory/
│   │   └── constitution.md     # This file
│   ├── templates/              # Spec templates
│   └── scripts/                # Automation scripts
├── specs/                      # Feature specifications
│   ├── features/
│   │   ├── authentication/
│   │   ├── task-crud/
│   │   └── ai-chatbot/         # Phase 3 specs
│   │       ├── spec.md
│   │       ├── plan.md
│   │       └── tasks.md
│   ├── api/
│   │   ├── rest-endpoints.md
│   │   └── mcp-tools.md        # Phase 3 MCP spec
│   ├── database/
│   │   └── schema.md           # Phase 2 + Phase 3
│   ├── devops/                 # Phase 4 DevOps specs
│   │   ├── containerization.md
│   │   ├── kubernetes.md
│   │   └── helm-charts.md
│   └── testing/
├── history/
│   ├── prompts/                # PHRs organized by feature
│   │   ├── phase-2/
│   │   ├── phase-3/
│   │   └── phase-4/
│   └── adr/                    # Architecture Decision Records
├── helm/                       # Helm charts for K8s deployment
│   └── todo-chatbot/
├── frontend/                   # Next.js application (Phase 2)
│   ├── CLAUDE.md              # Frontend-specific guidelines
│   ├── app/
│   ├── components/
│   ├── lib/
│   └── package.json
├── backend/                    # FastAPI application (Phase 2 + Phase 3)
│   ├── CLAUDE.md              # Backend-specific guidelines
│   ├── app/
│   │   ├── main.py           # FastAPI entry point
│   │   ├── models/           # SQLModel models (Phase 2 + Phase 3)
│   │   ├── routes/           # API endpoints (Phase 2 + Phase 3)
│   │   ├── services/         # Business logic
│   │   ├── middleware/       # Auth, CORS, etc.
│   │   └── mcp/              # MCP server implementation (Phase 3)
│   ├── Dockerfile            # Containerization spec
│   ├── tests/
│   └── pyproject.toml
├── CLAUDE.md                   # Root guidelines
└── README.md                   # Project documentation
```

---

## Authentication & Security Standards

### JWT Token Implementation
- **Library**: Better Auth (configured for JWT)
- **Secret Management**: `BETTER_AUTH_SECRET` environment variable (never committed)
- **Token Payload**: Must include `user_id`, `email`, `exp` (expiry), `iat` (issued at)
- **Token Storage**: HttpOnly cookies (frontend) or localStorage (with XSS precautions)
- **Token Expiry**: 7 days (refresh tokens optional for Phase 3)
- **Kubernetes Secret**: Store in Kubernetes secret for containerized deployment

### Security Requirements
1. **Password Hashing**: bcrypt or argon2 (via Better Auth)
2. **SQL Injection Prevention**: SQLModel parameterized queries only
3. **XSS Protection**: Input sanitization, Content-Security-Policy headers
4. **CORS Configuration**: Restrict origins (localhost for dev, production domains for deploy)
5. **Rate Limiting**: 100 requests/minute per user (prevent abuse)
6. **Error Messages**: Never expose sensitive details (DB structure, stack traces)
7. **Container Security**: Non-root execution, minimal packages, vulnerability scanning
8. **Network Security**: Network policies, encrypted communication
9. **Secrets Management**: Kubernetes secrets for sensitive data

### User Isolation Tests (Required)
- Attempt to access `/api/{other_user_id}/tasks` with valid but different user token → 401
- Attempt to modify `/api/{other_user_id}/tasks/{id}` → 401
- Token expiry verification (7 days + 1 minute) → 401
- Invalid/malformed token → 401
- Missing Authorization header → 401

---

## Code Quality Standards

### TypeScript (Frontend)
- **Strict Mode**: `"strict": true` in tsconfig.json
- **No Any**: Avoid `any` type; use `unknown` or proper types
- **Interfaces**: Define interfaces for all props, API responses, state
- **Error Handling**: Typed error boundaries and try-catch blocks

### Python (Backend)
- **Type Hints**: 100% coverage (Mypy strict mode)
- **Pydantic**: Use for request/response validation
- **SQLModel**: Type-safe ORM queries
- **Ruff**: Linting + formatting (auto-fix on save)

### Container & Kubernetes Standards
- **Docker Security**: Multi-stage builds, non-root users, minimal base images
- **Helm Best Practices**: Parameterized configurations, proper templating
- **K8s Resource Management**: Proper requests/limits, health checks
- **Security Contexts**: Run containers with minimal privileges

### Testing Requirements (TDD - MANDATORY)

**Test-Driven Development Process:**
1. **Red**: Write failing test first
2. **Green**: Write minimal code to pass test
3. **Refactor**: Improve code while keeping tests green

**Backend Testing (pytest):**
- **Unit Tests**: 80%+ overall coverage, 100% for auth/security
- **Integration Tests**: All API endpoints with auth scenarios
- **Security Tests**: User isolation, SQL injection, XSS (MANDATORY)
- **Performance Tests**: JWT verification < 10ms, Task list < 200ms
- **Test Specs**: See `@specs/testing/backend-testing.md`

**Frontend Testing (Vitest + React Testing Library):**
- **Component Tests**: 70%+ overall coverage, 90%+ for auth/task components
- **Unit Tests**: API client functions, utilities, hooks
- **Accessibility Tests**: Keyboard navigation, screen reader labels
- **Test Specs**: See `@specs/testing/frontend-testing.md`

**E2E Testing (Playwright):**
- **Critical Flows**: 100% coverage (signup, login, create task, complete, logout)
- **Cross-Browser**: Chrome, Firefox, Safari
- **Performance**: Page load < 2s, task list load < 500ms
- **Test Specs**: See `@specs/testing/e2e-testing.md`

**Kubernetes Testing:**
- **Deployment Tests**: 100% coverage for pod scheduling, service discovery
- **Scaling Tests**: Horizontal Pod Autoscaler functionality
- **Health Tests**: Liveness/readiness probe validation
- **Security Tests**: Network policy enforcement, RBAC validation
- **Integration Tests**: End-to-end functionality in K8s environment

**Testing Philosophy**: See `@specs/testing/overview.md` for complete testing strategy

---

## Development Workflow

### Spec-Driven Iteration Cycle
```
1. /sp.specify    → Write feature specification
2. /sp.clarify    → Ask 2-5 targeted questions to eliminate ambiguity
3. /sp.plan       → Create architecture plan (tech decisions, API contracts)
4. /sp.tasks      → Break down into atomic, testable tasks
5. /sp.analyze    → Cross-check spec/plan/tasks for consistency
6. /sp.implement  → Generate code via Claude Code
7. Test & Verify  → Run tests, check security, validate UI
8. Iterate        → If issues found, refine spec (NOT code) and regenerate
```

### Prompt History Records (PHRs)
- **Creation**: After EVERY user interaction (automatic)
- **Location**: `history/prompts/{feature-name}/`
- **Naming**: `{ID}-{slug}.{stage}.prompt.md`
- **Required Fields**: ID, title, stage, date, user input (verbatim), AI response

### Architecture Decision Records (ADRs)
- **Trigger**: Significant architectural decisions (framework choice, auth strategy, DB schema)
- **Process**: Suggest ADR creation; wait for user consent
- **Location**: `history/adr/`
- **Template**: Use `.specify/templates/adr-template.md`

---

## Constraints

### Prohibited Actions
- ❌ Manual code writing or editing (incl. Docker/YAML/CLI)
- ❌ Inline styles (use Tailwind classes only)
- ❌ Hardcoded secrets (use environment variables)
- ❌ Production cloud deployment (Minikube only for Phase 4)
- ❌ Skipping spec/plan/tasks stages
- ❌ Skipping AI tools (agents/skills first)
- ❌ Direct kubectl usage without AI assistance (except emergencies)

### Required Actions
- ✅ Use Context7 MCP for tech documentation
- ✅ Create PHRs for all interactions
- ✅ Write specs BEFORE code generation
- ✅ Test user isolation security
- ✅ Deploy to Minikube with Helm
- ✅ Containerize all services
- ✅ Implement AI-assisted operations

### Platform Requirements
- **Windows Users**: MUST develop in WSL 2
- **Local Development**: Minikube for Kubernetes
- **Environment Files**: `.env.local` (frontend), `.env` (backend) with templates in repo
- **Container Registry**: Local registry or Docker Hub for image storage

---

## Success Criteria

### Functional Requirements
- ✅ Fully working multi-user web app
- ✅ All Basic, Intermediate, and Advanced features implemented
- ✅ Secure authentication with JWT
- ✅ Persistent storage in Neon PostgreSQL
- ✅ Responsive UI with animations
- ✅ Browser notifications for reminders

### Security Requirements
- ✅ User isolation verified (no cross-user access)
- ✅ JWT token validation on all protected endpoints
- ✅ Unauthorized requests return 401
- ✅ Passwords hashed (never stored plaintext)
- ✅ SQL injection prevented (parameterized queries)
- ✅ Container security best practices implemented
- ✅ Kubernetes network policies enforced

### DevOps Requirements (Phase 4)
- ✅ Next.js frontend containerized with optimized Dockerfile
- ✅ FastAPI backend containerized with optimized Dockerfile
- ✅ Helm charts generated for application deployment
- ✅ Successful deployment to Minikube
- ✅ AI-assisted operations demonstrated (kubectl-ai, kagent)
- ✅ Auto-scaling configuration validated
- ✅ Health monitoring implemented
- ✅ Proper resource requests/limits defined

### Documentation Requirements
- ✅ Complete specs folder with refinement history
- ✅ PHRs demonstrating spec-driven process
- ✅ ADRs for major architectural decisions
- ✅ README with setup instructions
- ✅ API documentation (OpenAPI/Swagger)
- ✅ DevOps documentation for Kubernetes deployment

### Deployment Requirements
- ✅ Frontend deployed to Minikube via Helm
- ✅ Backend API deployed to Minikube via Helm
- ✅ MCP Server deployed to Minikube via Helm
- ✅ Database connection maintained (Neon PostgreSQL)
- ✅ Environment variables configured in Kubernetes
- ✅ Live demo accessible via Minikube

### Hackathon Judging Criteria

**Phase 2:**
- ✅ Clear evidence of spec-driven process (specs, PHRs, iterations)
- ✅ No manual code editing (all AI-generated)
- ✅ Security best practices demonstrated
- ✅ Modern, polished UI/UX
- ✅ Ready for Phase III progression (AI chatbot integration)

**Phase 3:**
- ✅ AI chatbot conversationally manages Basic Level features
- ✅ MCP server with stateless architecture
- ✅ Full integration with Phase 2 data and security
- ✅ 100% test coverage for chat flows and security
- ✅ Pure spec-driven implementation (zero manual code)
- ✅ Ready for Phase IV progression (Kubernetes deployment)

**Phase 4:**
- ✅ Containerized Next.js frontend and FastAPI backend
- ✅ Helm charts for declarative deployments
- ✅ Successful deployment to Minikube
- ✅ AI-assisted operations (Gordon, kubectl-ai, kagent)
- ✅ Reusable intelligence via subagents and skills (+200 bonus)
- ✅ Cloud-native blueprints generated and applied (+200 bonus)
- ✅ Zero manual DevOps code (all AI-generated)
- ✅ Process review passed with spec-driven DevOps

---

## Governance & Versioning

This constitution supersedes all other development practices and guidelines. ALL team members (human architects and AI agents) MUST adhere to these principles.

### Amendment Process

**Requirements for Constitution Changes:**
- Document rationale in Architecture Decision Record (ADR)
- Clear justification (architectural significance, not convenience)
- Explicit user approval via `/sp.constitution` command
- Migration plan for affected code/specs
- Update version number per semantic versioning

### Version Strategy

**Semantic Versioning:** MAJOR.MINOR.PATCH

- **MAJOR**: Backward-incompatible principle changes or removals (Phase 5+)
- **MINOR**: New principle added, significant expansion, or Phase progression
- **PATCH**: Clarifications, wording fixes, non-semantic refinements

**Examples:**
- 1.0.0 → 1.1.0: Add Phase 3 (new phase, expanded principles)
- 1.1.0 → 1.1.1: Clarify MCP tool parameter names (wording only)
- 1.2.0 → 1.3.0: Add Phase 4 (Kubernetes deployment, DevOps principles)
- 1.1.0 → 2.0.0: Remove TDD requirement (major change)

### Enforcement

- All PRs/reviews verify compliance with current version
- Complexity/exceptions require documented justification
- Use `CLAUDE.md` files (root, frontend, backend, phase-4 if needed) for runtime development guidance
- PHRs track all significant decisions and iterations

### Review Schedule

- **Before Phase V Initiation**: Next major review
- **Quarterly**: Minor updates and clarifications
- **As-needed**: Amendment via `/sp.constitution` for new phases

---

## Sync Impact Report

**Amendment Version**: 1.2.0 → 1.3.0

**Rationale**: Addition of Phase 4 requirements for Local Kubernetes Deployment with AI-assisted DevOps, containerization standards, and cloud-native deployment principles. This expands the constitution to cover DevOps practices, containerization requirements, and Kubernetes deployment specifics while maintaining compatibility with existing phases.

**Modified/Added Principles:**
- ✅ XI. AI-Assisted DevOps & Infrastructure as Code: New section for Phase 4 DevOps requirements
- ✅ IV. Use Subagents and Skills: Added DevOps-related subagents
- ✅ Updated Constraints: Added Kubernetes-specific requirements
- ✅ Updated Success Criteria: Added Phase 4 requirements

**New Major Sections:**
- ✅ Phase 4: Local Kubernetes Deployment: Complete section on cloud-native deployment
- ✅ DevOps & Containerization Standards: Comprehensive DevOps standards section

**Templates Requiring Updates:**
- ✅ `@specs/templates/spec-template.md` - Needs Phase 4 DevOps updates
- ✅ `@specs/templates/plan-template.md` - Needs Kubernetes architecture updates
- ⚠ `@specs/templates/tasks-template.md` - May need containerization/deployment task updates

**Follow-up Tasks:**
- Create Phase 4 specification files in `specs/devops/`
- Create containerization specs in `specs/devops/containerization.md`
- Create Kubernetes specs in `specs/devops/kubernetes.md`
- Create Helm chart specs in `specs/devops/helm-charts.md`
- Update CLAUDE.md files to reference Phase 4 workflows
- Create Kubernetes deployment testing specifications
- Set up Helm chart repository structure in `/helm/`

---

## Governance & Versioning (Continued)

**Version**: 1.3.0
**Ratified**: 2026-01-02 (Phase 2)
**Last Amended**: 2026-01-26 (Phase 4 Kubernetes)
**Amendment Type**: MINOR (Added Phase 4 + DevOps principles)
**Next Review**: Before Phase V (Production Cloud Deployment)
**Status**: Active for Phases 2-4