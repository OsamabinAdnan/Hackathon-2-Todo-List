# Implementation Plan: Advanced Level Features - Intelligent Task Management

**Branch**: `main` | **Date**: 2025-12-31 | **Spec**: [spec.md](./spec.md)
**Input**: Feature specification from `specs/advanced-features/spec.md`

## Summary

Level 3 Advanced Features adds intelligent task management capabilities to the existing Todo CLI application. The primary requirements are:

1. **Recurring Tasks**: Automatic rescheduling of tasks (daily/weekly/monthly patterns) upon completion
2. **Due Date/Time Precision**: Upgrade from date-only to datetime tracking for time-sensitive deadlines
3. **Reminder System**: Proactive console-based notifications for overdue and due-soon tasks

**Technical Approach**:
- Extend existing `Task` dataclass with `recurrence` enum and upgrade `due_date` from `date` to `datetime`
- Implement auto-rescheduling logic in task completion workflow (clone-and-add pattern)
- Add reminder detection service checking for overdue (now > due) and due-soon (within 60 minutes) tasks
- Enhance CLI commands and interactive menu to support new attributes
- Use stdlib `datetime`/`timedelta` for date calculations; no new external dependencies
- Display reminders using Rich panels with color-coded styling on app startup and list operations

## Technical Context

**Language/Version**: Python 3.13+
**Primary Dependencies**: Typer (CLI), Rich (output styling), pytest (testing)
**Storage**: In-memory dictionary-based storage (Phase 1 constraint)
**Testing**: pytest with unit tests for recurrence calculations, reminder logic, and datetime handling
**Target Platform**: Cross-platform console CLI (Windows/macOS/Linux)
**Project Type**: Single project with CLI interface
**Performance Goals**:
- Recurring task rescheduling within 5 seconds of completion
- Reminder display within 1 second of app startup
- Handle 100% of month-end edge cases for monthly recurrence

**Constraints**:
- No new external dependencies beyond existing Typer, Rich, and stdlib
- No persistent storage (in-memory only)
- No background processes or daemon threads
- No timezone support (local system time only)
- Console-only reminders (no OS-level notifications)

**Scale/Scope**:
- Extends existing Level 1 (Basic CRUD) and Level 2 (Priorities, Tags, Filtering, Search, Sorting) features
- 3 prioritized user stories with 25 functional requirements
- 8 measurable success criteria
- Integration with interactive menu system

## Constitution Check

*GATE: Must pass before Phase 0 research. Re-check after Phase 1 design.*

‚úÖ **Spec-Driven Development**: All code generated by Claude Code based on approved spec
‚úÖ **Architecture First**: Type-safe extensions to existing clean architecture
‚úÖ **Clean Code Standards**: PEP 8 compliant, descriptive naming, single responsibility
‚úÖ **Test-First Development**: Unit tests for recurrence calculations and reminder logic
‚úÖ **Rich CLI Experience**: Enhanced Typer/Rich integration for new features
‚úÖ **UV Package Management**: Continue using UV for dependency management

**No Constitution Violations**: This implementation builds on existing architecture without introducing new patterns or dependencies.

## Project Structure

### Documentation (this feature)

```text
specs/advanced-features/
‚îú‚îÄ‚îÄ spec.md              # Feature specification (completed)
‚îú‚îÄ‚îÄ plan.md              # This file (current)
‚îú‚îÄ‚îÄ tasks.md             # Implementation tasks (next: /sp.tasks command)
‚îî‚îÄ‚îÄ checklists/
    ‚îî‚îÄ‚îÄ requirements.md  # Validation checklist
```

### Source Code (repository root)

```text
src/todo/
‚îú‚îÄ‚îÄ models/
‚îÇ   ‚îî‚îÄ‚îÄ task.py          # MODIFY: Add Recurrence enum, upgrade due_date to datetime
‚îú‚îÄ‚îÄ services/
‚îÇ   ‚îú‚îÄ‚îÄ task_service.py  # MODIFY: Add reschedule logic, reminder detection
‚îÇ   ‚îî‚îÄ‚îÄ results.py       # MODIFY: Add ReminderResult dataclass
‚îú‚îÄ‚îÄ storage/
‚îÇ   ‚îî‚îÄ‚îÄ task_store.py    # MODIFY: Handle datetime serialization
‚îî‚îÄ‚îÄ cli/
    ‚îî‚îÄ‚îÄ views/
        ‚îú‚îÄ‚îÄ formatters.py # MODIFY: Add recurrence column, datetime formatting, overdue styling
        ‚îî‚îÄ‚îÄ menu.py       # MODIFY: Add recurrence/datetime input prompts

main.py                  # MODIFY: Add reminder display on startup

tests/
‚îú‚îÄ‚îÄ unit/
‚îÇ   ‚îú‚îÄ‚îÄ test_recurrence.py  # NEW: Test recurrence calculations
‚îÇ   ‚îú‚îÄ‚îÄ test_reminders.py   # NEW: Test reminder detection logic
‚îÇ   ‚îî‚îÄ‚îÄ test_datetime.py    # NEW: Test datetime parsing and validation
‚îî‚îÄ‚îÄ cli/
    ‚îî‚îÄ‚îÄ test_menu_integration.py  # MODIFY: Add Level 3 integration tests
```

**Structure Decision**: Single project structure (src/todo/) maintained. All Level 3 features integrate into existing layers:
- **Models layer**: Extended Task dataclass with new attributes
- **Services layer**: Added recurrence and reminder business logic
- **CLI layer**: Enhanced commands and menu to support new features
- **Tests layer**: New test modules for Level 3 logic

## Architectural Decisions

### ADR-001: Recurrence Model Design

**Context**: Need to represent recurring task patterns (daily, weekly, monthly).

**Decision**: Use simple `Recurrence` IntEnum with three values: DAILY, WEEKLY, MONTHLY (plus NONE for non-recurring tasks).

**Alternatives Considered**:
1. ~~Flexible timedelta-based system~~ - Rejected: Adds complexity; monthly recurrence doesn't map cleanly to timedelta
2. ~~Cron-like expression parser~~ - Rejected: Over-engineered for three simple patterns; adds external dependency
3. **Simple Enum (CHOSEN)** - Accepted: Meets all requirements, no dependencies, easy to calculate next occurrence

**Implementation**:
```python
class Recurrence(IntEnum):
    NONE = 0      # Non-recurring task
    DAILY = 1     # Repeat every day
    WEEKLY = 2    # Repeat every 7 days
    MONTHLY = 3   # Repeat on same day of month
```

**Consequences**:
- ‚úÖ Simple to implement and test
- ‚úÖ No external dependencies
- ‚úÖ Clear user mental model
- ‚ùå Cannot support custom intervals (e.g., "every 2 weeks") - acceptable for Phase 1

---

### ADR-002: Due Date Field Upgrade Strategy

**Context**: Need to add time precision to existing date-only `due_date` field for Level 3.

**Decision**: Upgrade `due_date` field from `date` type to `datetime` type, maintaining backward compatibility by treating date-only values as midnight (00:00) on that date.

**Alternatives Considered**:
1. ~~Add separate `due_time` field~~ - Rejected: Creates confusion, requires coordinating two fields
2. ~~Create new `due_datetime` field, deprecate `due_date`~~ - Rejected: Breaking change, complicates data model
3. **Upgrade field type (CHOSEN)** - Accepted: Clean upgrade path, backward compatible

**Implementation**:
```python
@dataclass
class Task:
    # ... existing fields ...
    due_date: Optional[datetime] = None  # Changed from date to datetime
    recurrence: Recurrence = Recurrence.NONE  # NEW field
```

**Backward Compatibility**:
- CLI accepts both "YYYY-MM-DD" (date-only) and "YYYY-MM-DD HH:MM" (datetime) formats
- Date-only input creates datetime at 00:00 on that date
- Display shows time only when hour/minute are non-zero
- Sorting works correctly (datetime comparison handles both cases)

**Consequences**:
- ‚úÖ Clean data model (single field for due information)
- ‚úÖ Backward compatible with Level 2 date-only tasks
- ‚úÖ Enables time-based reminders
- ‚ö†Ô∏è  Requires updating serialization logic in TaskStore

---

### ADR-003: Auto-Reschedule Behavior

**Context**: When a recurring task is marked complete, need to create the next occurrence.

**Decision**: Clone the completed task with a new ID and updated due date, add it to the store, and keep the original task as completed (history preservation).

**Alternatives Considered**:
1. ~~Update completed task's due_date in place, reset completed flag~~ - Rejected: Loses completion history
2. ~~Delete completed task, create new one~~ - Rejected: Inconsistent with user expectation of "marking complete"
3. **Clone-and-add pattern (CHOSEN)** - Accepted: Preserves history, clear user model

**Implementation Flow**:
```python
def toggle_task_completion(task_id: int) -> OperationResult:
    task = get_task(task_id)
    task.completed = not task.completed

    if task.completed and task.recurrence != Recurrence.NONE:
        # Calculate next occurrence
        next_due = calculate_next_occurrence(task.due_date, task.recurrence)

        # Clone task with new ID
        new_task = Task(
            id=generate_new_id(),
            title=task.title,
            description=task.description,
            completed=False,
            priority=task.priority,
            tags=task.tags,
            due_date=next_due,
            recurrence=task.recurrence,
            created_at=datetime.now(),
            updated_at=None
        )

        # Add to store
        add_task(new_task)

    return OperationResult(success=True)
```

**Next Occurrence Calculation**:
- DAILY: `due_date + timedelta(days=1)`
- WEEKLY: `due_date + timedelta(weeks=1)`
- MONTHLY: `due_date + relativedelta(months=1)` with edge case handling:
  - Jan 31 ‚Üí Feb 28/29 (last day of month)
  - Leap year handling (Feb 29 ‚Üí Feb 28 in non-leap year)

**Consequences**:
- ‚úÖ Preserves completion history
- ‚úÖ Clear mental model for users
- ‚úÖ Supports multiple rapid completions (each creates next instance)
- ‚ö†Ô∏è  Task list grows over time (acceptable for in-memory Phase 1)

---

### ADR-004: Reminder Detection Strategy

**Context**: Need to proactively notify users of overdue and upcoming tasks.

**Decision**: Implement reminder detection as a service method that checks all incomplete tasks against current datetime, classifying them as overdue or due-soon based on fixed thresholds.

**Thresholds**:
- **Overdue**: `current_datetime > task.due_date`
- **Due Soon**: `current_datetime <= task.due_date < current_datetime + 60 minutes`

**Alternatives Considered**:
1. ~~Configurable thresholds (user preferences)~~ - Rejected: Adds complexity; no UI for configuration in Phase 1
2. ~~Multiple threshold levels (1 hour, 1 day, 1 week)~~ - Rejected: Over-engineered for console app
3. **Fixed thresholds (CHOSEN)** - Accepted: Simple, predictable, meets success criteria

**Implementation**:
```python
@dataclass
class ReminderResult:
    overdue_tasks: list[Task]
    due_soon_tasks: list[Task]
    overdue_count: int
    due_soon_count: int

def check_reminders() -> ReminderResult:
    now = datetime.now()
    soon_threshold = now + timedelta(minutes=60)

    incomplete_tasks = [t for t in get_all_tasks() if not t.completed and t.due_date]

    overdue = [t for t in incomplete_tasks if t.due_date < now]
    due_soon = [t for t in incomplete_tasks if now <= t.due_date < soon_threshold]

    return ReminderResult(
        overdue_tasks=overdue,
        due_soon_tasks=due_soon,
        overdue_count=len(overdue),
        due_soon_count=len(due_soon)
    )
```

**Display Triggers**:
1. **App startup**: Display reminder panel before showing main menu
2. **List command**: Display reminder panel before showing task table
3. **Filter/Search commands**: Display reminder panel before results

**Consequences**:
- ‚úÖ Simple to implement and test
- ‚úÖ Predictable user experience
- ‚úÖ No configuration complexity
- ‚ùå Cannot customize thresholds per user - acceptable for Phase 1

---

### ADR-005: Notification Display Method

**Context**: Need to present reminders to users in the console.

**Decision**: Use Rich library's `Panel` and `Text` components with color-coded styling to display reminder summaries and details in the console.

**Alternatives Considered**:
1. ~~OS-level system notifications (Windows toast, macOS notifier, Linux notify-send)~~ - Rejected: Platform-specific, may fail silently, adds complexity (see spec clarification)
2. ~~Terminal bell/beep~~ - Rejected: Annoying, not informative, accessibility issues
3. **Rich console panels (CHOSEN)** - Accepted: Cross-platform, visually clear, no dependencies

**Implementation Example**:
```python
from rich.panel import Panel
from rich.text import Text
from rich.console import Console

def display_reminders(result: ReminderResult) -> None:
    if result.overdue_count == 0 and result.due_soon_count == 0:
        return  # No reminders to show

    console = Console()
    content = Text()

    if result.overdue_count > 0:
        content.append(f"‚ö†Ô∏è  {result.overdue_count} overdue task(s)\n", style="bold red")
        for task in result.overdue_tasks[:5]:  # Show max 5
            time_diff = humanize_time_diff(datetime.now() - task.due_date)
            content.append(f"  ‚Ä¢ {task.title} ({time_diff} overdue)\n", style="red")

    if result.due_soon_count > 0:
        content.append(f"‚è∞ {result.due_soon_count} due soon\n", style="bold yellow")
        for task in result.due_soon_tasks[:5]:
            time_diff = humanize_time_diff(task.due_date - datetime.now())
            content.append(f"  ‚Ä¢ {task.title} (due in {time_diff})\n", style="yellow")

    console.print(Panel(content, title="üìã Reminders", border_style="cyan"))
```

**Consequences**:
- ‚úÖ Cross-platform compatibility
- ‚úÖ Visually prominent without being intrusive
- ‚úÖ Leverages existing Rich dependency
- ‚úÖ Consistent with app's existing UX
- ‚ùå Requires terminal to be visible - acceptable for console CLI

---

### ADR-006: Reminder Trigger Points

**Context**: When should the app check and display reminders?

**Decision**: Integrate reminder checks into two trigger points: app startup (main menu entry) and list operations (list/filter/search commands).

**Alternatives Considered**:
1. ~~Separate `/remind` command~~ - Rejected: Users forget to run it; defeats "proactive" goal
2. ~~Background thread checking periodically~~ - Rejected: Violates Phase 1 constraints (no background processes)
3. ~~Every command execution~~ - Rejected: Too intrusive (e.g., reminders on update/delete commands)
4. **App startup + list operations (CHOSEN)** - Accepted: Balances proactivity with non-intrusiveness

**Implementation Points**:
1. **main.py - App Entry**: Call `check_reminders()` and `display_reminders()` before showing interactive menu
2. **List Command**: Call reminder check before displaying task table
3. **Filter Command**: Call reminder check before displaying filtered results
4. **Search Command**: Call reminder check before displaying search results

**Consequences**:
- ‚úÖ Users see reminders naturally during workflow
- ‚úÖ Not overly intrusive (skipped for add/update/delete/toggle commands)
- ‚úÖ No background processes needed
- ‚ö†Ô∏è  Reminders only shown when user interacts with app - acceptable for console CLI

## Implementation Phases

### Phase 0: Research & Validation

**Goal**: Validate technical approach and edge case handling before implementation.

**Tasks**:
1. Research stdlib `datetime` and `timedelta` API for date calculations
2. Test month-end edge cases (Jan 31 ‚Üí Feb, leap year handling)
3. Validate datetime parsing for "YYYY-MM-DD HH:MM" format
4. Confirm Rich Panel/Text API for reminder display styling
5. Review existing codebase to identify integration points

**Acceptance Criteria**:
- Month-end calculation logic documented with test cases
- Datetime parsing function prototype validated
- Rich styling examples confirmed working

**Output**: `specs/advanced-features/research.md` (if needed for complex edge cases)

---

### Phase 1: Data Model Extension

**Goal**: Extend Task dataclass with recurrence and upgrade due_date to datetime.

**Sub-tasks**:

1. **Add Recurrence Enum** (src/todo/models/task.py)
   - Define `Recurrence` IntEnum with NONE, DAILY, WEEKLY, MONTHLY
   - Add to model module exports

2. **Upgrade Task.due_date Field** (src/todo/models/task.py)
   - Change type from `Optional[date]` to `Optional[datetime]`
   - Update `__post_init__` validation if needed
   - Update `to_dict()` to serialize datetime
   - Update `from_dict()` to deserialize datetime

3. **Add Task.recurrence Field** (src/todo/models/task.py)
   - Add `recurrence: Recurrence = Recurrence.NONE` field
   - Update `to_dict()` to include recurrence
   - Update `from_dict()` to parse recurrence

4. **Update TaskStore Serialization** (src/todo/storage/task_store.py)
   - Handle datetime serialization in storage operations
   - Ensure backward compatibility with existing date-only tasks

**Acceptance Criteria**:
- Task dataclass has recurrence field (default NONE)
- Task.due_date is datetime type (accepts None)
- TaskStore correctly serializes/deserializes datetime
- Existing Level 1/2 tests still pass (backward compatibility)

**Output**: Updated `src/todo/models/task.py` and `src/todo/storage/task_store.py`

---

### Phase 2: Recurrence Calculation Logic

**Goal**: Implement next occurrence calculation for recurring tasks.

**Sub-tasks**:

1. **Create Recurrence Calculator** (src/todo/services/task_service.py)
   - Add `calculate_next_occurrence(due_date: datetime, recurrence: Recurrence) -> datetime` method
   - Implement DAILY logic: `due_date + timedelta(days=1)`
   - Implement WEEKLY logic: `due_date + timedelta(weeks=1)`
   - Implement MONTHLY logic with edge case handling:
     - Use `dateutil.relativedelta` if available, else pure `datetime` arithmetic
     - Handle month-end: Jan 31 ‚Üí Feb 28/29 (last day of month)
     - Handle leap year: Feb 29 ‚Üí Feb 28 in non-leap year
   - Raise ValueError for NONE recurrence

2. **Add Unit Tests** (tests/unit/test_recurrence.py)
   - Test DAILY: next day calculation
   - Test WEEKLY: +7 days calculation
   - Test MONTHLY: same day next month
   - Test MONTHLY edge cases: Jan 31 ‚Üí Feb 28, Feb 29 ‚Üí Mar 1 (non-leap), Dec 31 ‚Üí Jan 31
   - Test error handling for NONE recurrence

**Acceptance Criteria**:
- `calculate_next_occurrence()` correctly handles all recurrence patterns
- 100% test coverage for month-end edge cases
- All edge case tests pass

**Output**: Recurrence calculation logic in `task_service.py` and `test_recurrence.py`

---

### Phase 3: Auto-Reschedule on Completion

**Goal**: Automatically create next task instance when completing a recurring task.

**Sub-tasks**:

1. **Modify Toggle Completion Logic** (src/todo/services/task_service.py)
   - Update `toggle_task_completion()` method:
     - Check if task has recurrence (not NONE) and is being marked complete
     - Calculate next occurrence date
     - Clone task with new ID, reset completed flag, update due_date
     - Add cloned task to store using existing `add_task()` method
   - Preserve original completed task (history)

2. **Add Integration Tests** (tests/unit/test_recurrence.py)
   - Test completing daily recurring task creates tomorrow's instance
   - Test completing weekly recurring task creates next week's instance
   - Test completing monthly recurring task creates next month's instance
   - Test original task remains completed after rescheduling
   - Test non-recurring task completion doesn't create new instance
   - Test multiple rapid completions create sequence of future instances

**Acceptance Criteria**:
- Completing recurring task creates new instance with correct next due date
- Original task remains marked complete
- New task has new unique ID and reset completed flag
- New task preserves title, description, priority, tags, recurrence
- Non-recurring tasks behave unchanged
- All integration tests pass

**Output**: Updated `task_service.py` with auto-reschedule logic and integration tests

---

### Phase 4: Reminder Detection Service

**Goal**: Implement service method to detect overdue and due-soon tasks.

**Sub-tasks**:

1. **Create ReminderResult Dataclass** (src/todo/services/results.py)
   - Add `ReminderResult` with fields: `overdue_tasks`, `due_soon_tasks`, `overdue_count`, `due_soon_count`

2. **Implement Reminder Detection** (src/todo/services/task_service.py)
   - Add `check_reminders() -> ReminderResult` method:
     - Get current datetime
     - Calculate due-soon threshold (now + 60 minutes)
     - Filter incomplete tasks with due_date
     - Classify as overdue if `due_date < now`
     - Classify as due_soon if `now <= due_date < threshold`
     - Return ReminderResult with counts and task lists

3. **Add Unit Tests** (tests/unit/test_reminders.py)
   - Test no reminders when all tasks completed or no due dates
   - Test overdue detection (past due_date)
   - Test due-soon detection (within 60 minutes)
   - Test boundary conditions (exactly at threshold)
   - Test tasks without due_date are excluded
   - Test date-only tasks (midnight datetime) are included in checks

**Acceptance Criteria**:
- `check_reminders()` correctly classifies overdue vs due-soon tasks
- Completed tasks excluded from reminders
- Tasks without due_date excluded
- All unit tests pass
- Returns empty result when no reminders

**Output**: Reminder detection in `task_service.py`, `ReminderResult` in `results.py`, and `test_reminders.py`

---

### Phase 5: CLI Input Enhancement

**Goal**: Add CLI options for recurrence and datetime input.

**Sub-tasks**:

1. **Update Add Command** (main.py)
   - Add `--recurring` option accepting "none|daily|weekly|monthly"
   - Parse and validate recurrence input
   - Update due date parsing to accept both "YYYY-MM-DD" and "YYYY-MM-DD HH:MM" formats
   - Default time to 00:00 if only date provided
   - Validate future datetime (reject past dates)
   - Pass recurrence and datetime to `task_service.add_task()`

2. **Update Update Command** (main.py)
   - Add `--recurring` option to modify recurrence pattern
   - Update `--due` option to accept datetime format
   - Pass updated values to `task_service.update_task()`

3. **Update Interactive Menu** (src/todo/cli/views/menu.py)
   - Add recurrence prompt in `handle_add_task()`:
     - "Recurring task? (none/daily/weekly/monthly) [none]"
     - Parse shorthand: n/d/w/m
   - Update due date prompt in `handle_add_task()` and `handle_update_task()`:
     - "Due date and time (YYYY-MM-DD HH:MM or YYYY-MM-DD)"
     - Accept both formats
     - Validate future datetime
     - Show example: "e.g., 2025-01-15 14:30 or 2025-01-15"
   - Add recurrence option to update menu

4. **Add Input Validation Helpers** (src/todo/cli/views/menu.py)
   - `parse_recurrence_input(value: str) -> Recurrence` - accept shortcuts
   - `parse_datetime_input(value: str) -> Optional[datetime]` - accept date or datetime
   - `validate_future_datetime(dt: datetime) -> bool` - reject past

**Acceptance Criteria**:
- CLI `add` command accepts `--recurring` option
- CLI `add` and `update` commands accept datetime format for `--due`
- Interactive menu prompts for recurrence pattern
- Interactive menu accepts datetime input for due dates
- Input validation rejects past datetimes
- Shorthand inputs work (n/d/w/m for recurrence)
- Date-only input defaults to 00:00 time

**Output**: Updated `main.py` and `menu.py` with new input options

---

### Phase 6: Display Enhancements

**Goal**: Show recurrence info and enhanced datetime in task lists.

**Sub-tasks**:

1. **Add Recurrence Column** (src/todo/cli/views/formatters.py)
   - Add "Recurrence" column to task table
   - Display pattern: "Daily", "Weekly", "Monthly", or "-" for NONE
   - Use visual indicator (e.g., "üîÅ Daily")

2. **Enhance Due Date Column** (src/todo/cli/views/formatters.py)
   - Display datetime in readable format: "2025-01-15 02:00 PM"
   - Show date-only when time is 00:00: "2025-01-15"
   - Add overdue styling: red + bold for tasks past due
   - Add due-soon styling: yellow for tasks within 1 hour

3. **Add Overdue Status Indicator** (src/todo/cli/views/formatters.py)
   - Check if task is overdue (due_date < now)
   - Add visual indicator in Status column: "‚ö†Ô∏è" for overdue
   - Apply red styling to entire overdue task row

4. **Update Column Widths** (src/todo/cli/views/formatters.py)
   - Adjust table layout to accommodate new/wider columns
   - Ensure readable display on standard 80-column terminals

**Acceptance Criteria**:
- Task table includes Recurrence column with pattern display
- Due Date column shows time when present (not 00:00)
- Overdue tasks highlighted in red with warning indicator
- Due-soon tasks highlighted in yellow
- Table layout remains readable
- All existing columns still visible

**Output**: Updated `formatters.py` with enhanced table display

---

### Phase 7: Reminder Display Integration

**Goal**: Display reminder panels on app startup and list operations.

**Sub-tasks**:

1. **Create Reminder Display Function** (src/todo/cli/views/formatters.py)
   - Add `display_reminders(result: ReminderResult) -> None` function
   - Use Rich Panel with title "üìã Reminders"
   - Show overdue count and list (max 5 tasks)
   - Show due-soon count and list (max 5 tasks)
   - Apply color styling: red for overdue, yellow for due-soon
   - Include humanized time differences (e.g., "2 hours overdue", "due in 30 min")

2. **Integrate into App Startup** (main.py)
   - In `main_callback()` (interactive menu entry):
     - Call `task_service.check_reminders()`
     - If reminders exist, call `display_reminders()`
     - Display before showing main menu

3. **Integrate into List Command** (main.py)
   - In `list_tasks()` command:
     - Call `check_reminders()` before displaying table
     - Display reminder panel if reminders exist
     - Then display task table as usual

4. **Integrate into Interactive Menu List** (src/todo/cli/views/menu.py)
   - In `handle_list_tasks()`:
     - Call `check_reminders()` and `display_reminders()`
     - Then display task table

5. **Integrate into Filter/Search** (src/todo/cli/views/menu.py)
   - In `handle_filter_tasks()` and `handle_search_tasks()`:
     - Call `check_reminders()` and `display_reminders()`
     - Then display filtered/search results

6. **Add Humanize Time Helper** (src/todo/cli/views/formatters.py or utils)
   - Create `humanize_time_diff(td: timedelta) -> str` helper
   - Format as "X hours Y mins" or "X days" or "Y mins"
   - Handle both positive (future) and negative (past) deltas

**Acceptance Criteria**:
- Reminder panel displays on app startup before menu
- Reminder panel displays before list/filter/search results
- Panel shows overdue and due-soon counts
- Panel shows up to 5 tasks per category with humanized time
- Panel uses Rich styling (red/yellow colors, borders)
- Panel only appears when reminders exist (silent when none)

**Output**: Reminder display in `formatters.py` and integration in `main.py` and `menu.py`

---

### Phase 8: Testing & Validation

**Goal**: Comprehensive testing and validation of Level 3 features.

**Sub-tasks**:

1. **Unit Test Completion** (tests/unit/)
   - Ensure 100% coverage for recurrence calculations
   - Ensure 100% coverage for reminder detection
   - Ensure 100% coverage for datetime parsing/validation
   - Add edge case tests:
     - No recurrence, no due date
     - Invalid recurrence input
     - Invalid datetime format
     - Multiple rapid completions of same recurring task

2. **Integration Testing** (tests/cli/)
   - Test full workflow: add recurring task ‚Üí complete ‚Üí verify new instance
   - Test reminder display on startup with overdue/due-soon tasks
   - Test datetime input via CLI and interactive menu
   - Test Level 3 features don't break Level 1/2 functionality

3. **Manual CLI Testing Scenarios**
   - Add daily recurring task, mark complete, verify tomorrow's instance created
   - Add monthly task for Jan 31, complete, verify Feb 28/29 instance
   - Set task due in past, verify overdue reminder on startup
   - Set task due in 30 min, verify due-soon reminder
   - Complete recurring task multiple times rapidly, verify sequence

4. **Success Criteria Validation**
   - SC-001: Recurring task completion creates next instance within 5 seconds ‚úì
   - SC-002: Datetime precision displayed in lists ‚úì
   - SC-003: Reminders appear within 1 second of startup ‚úì
   - SC-004: 100% month-end edge cases handled ‚úì
   - SC-005: All attributes displayed in menu and CLI ‚úì
   - SC-006: Multiple completions create correct sequence ‚úì
   - SC-007: Reminder system correctly classifies overdue/due-soon ‚úì
   - SC-008: Level 1/2 features still work (regression testing) ‚úì

5. **Error Handling & Help Text**
   - Update CLI `--help` for new options
   - Update interactive menu help (option 0)
   - Add error messages for invalid inputs
   - Test graceful handling of edge cases

**Acceptance Criteria**:
- All unit tests pass with >95% coverage for new code
- Integration tests confirm Level 3 features work end-to-end
- Manual testing checklist 100% complete
- All 8 success criteria validated
- Help text updated and accurate
- No regressions in Level 1/2 functionality

**Output**: Complete test suite in `tests/` and validation report

## Risk Analysis

### High-Impact Risks

| Risk | Likelihood | Impact | Mitigation Strategy |
|------|------------|--------|---------------------|
| Month-end edge cases cause incorrect rescheduling | Medium | High | Implement comprehensive edge case tests before coding; use proven stdlib date arithmetic; validate against known calendar |
| Datetime upgrade breaks Level 2 date-only tasks | Medium | High | Design backward-compatible parsing (accept both formats); extensive regression testing; default time to 00:00 for date-only |
| Reminder detection performance degrades with many tasks | Low | Medium | Reminder check is O(n) over incomplete tasks; acceptable for in-memory Phase 1; optimize only if profiling shows issue |
| Auto-reschedule creates infinite loops | Low | High | Ensure only completed tasks trigger reschedule; new task always has completed=False; add safeguard check |
| Rich styling breaks on some terminals | Low | Low | Use fallback plain text if Rich fails; test on Windows/macOS/Linux terminals |

### Mitigation Actions

1. **Edge Case Testing First**: Write and validate month-end test cases before implementing recurrence logic
2. **Backward Compatibility Tests**: Run full Level 1/2 test suite after datetime upgrade
3. **Performance Profiling**: Time reminder checks with 100+ tasks; optimize if >100ms
4. **Code Review Checkpoints**: Review auto-reschedule logic for infinite loop potential before merge
5. **Cross-Platform Testing**: Test on Windows, macOS, Linux before release

## Dependencies & Integration

### Internal Dependencies

**Extends Existing Code**:
- `src/todo/models/task.py` - Adds fields, maintains existing structure
- `src/todo/services/task_service.py` - Adds methods, existing methods unchanged
- `src/todo/cli/views/formatters.py` - Adds columns, existing display logic intact
- `main.py` - Adds reminder call, existing commands unchanged

**No Breaking Changes**: All Level 1 and Level 2 features continue to function as before.

### External Dependencies

**No New Dependencies**: Uses only stdlib (`datetime`, `timedelta`) and existing Typer/Rich.

**Existing Dependencies** (unchanged):
- Python 3.13+
- Typer (CLI framework)
- Rich (output styling)
- pytest (testing)

## Testing Strategy

### Unit Testing

**New Test Modules**:
1. `tests/unit/test_recurrence.py` - Recurrence calculation logic
2. `tests/unit/test_reminders.py` - Reminder detection logic
3. `tests/unit/test_datetime.py` - Datetime parsing and validation

**Coverage Goals**:
- 100% coverage for recurrence calculations (all patterns + edge cases)
- 100% coverage for reminder detection (overdue, due-soon, boundaries)
- 95%+ coverage for datetime input parsing

**Key Test Cases**:
- Daily recurrence: +1 day
- Weekly recurrence: +7 days
- Monthly recurrence: same day next month
- Month-end: Jan 31 ‚Üí Feb 28/29, Feb 29 ‚Üí Mar 1 (non-leap)
- Overdue detection: past due_date
- Due-soon detection: within 60 minutes
- Boundary: exactly at threshold
- Auto-reschedule: creates correct next instance
- Multiple completions: sequential future instances

### Integration Testing

**Test Scenarios**:
1. Full workflow: CLI add with recurrence ‚Üí mark complete ‚Üí verify new task
2. Interactive menu workflow: add recurring task ‚Üí complete ‚Üí list shows both
3. Reminder integration: set overdue task ‚Üí launch app ‚Üí see reminder panel
4. Datetime display: add task with time ‚Üí list ‚Üí verify time shown
5. Regression: run all Level 1/2 tests ‚Üí verify no failures

### Manual Testing Checklist

- [ ] Add daily recurring task "Daily standup", due tomorrow 9:00 AM
- [ ] Mark it complete, verify new instance created for next day
- [ ] Add monthly task "Pay rent" due Jan 31 2025
- [ ] Mark it complete, verify Feb 28/29 instance created
- [ ] Add task "Submit report" due 30 minutes from now
- [ ] Launch app, verify "due soon" reminder appears
- [ ] Add task "Overdue task" due yesterday
- [ ] Launch app, verify "overdue" reminder in red
- [ ] List tasks, verify recurrence column shows patterns
- [ ] List tasks, verify due dates show time when present
- [ ] Complete recurring task 3 times rapidly, verify 3 future instances
- [ ] Run `uv run main.py --help`, verify new options documented
- [ ] Run interactive menu option 0 (Help), verify Level 3 features listed

## Success Criteria Validation

After implementation, validate each success criterion:

- [ ] **SC-001**: Create recurring task, complete it, new instance appears in <5 sec
- [ ] **SC-002**: Add task with "2025-01-15 14:30", list shows "02:30 PM"
- [ ] **SC-003**: Launch app with overdue task, reminder appears in <1 sec
- [ ] **SC-004**: Test all month-end cases, verify correct next dates
- [ ] **SC-005**: List tasks, verify recurrence and datetime columns present
- [ ] **SC-006**: Complete recurring task 5 times, verify 5 future instances
- [ ] **SC-007**: Mix of overdue/due-soon/future tasks, verify correct classification
- [ ] **SC-008**: Run all Level 1/2 tests, confirm no regressions

## Implementation Notes

### Code Generation Workflow

All code MUST be generated by Claude Code following the Spec-Driven Development workflow:

1. Read spec section for current sub-task
2. Read current codebase context (relevant files)
3. Generate code based on spec requirements
4. Validate against acceptance criteria
5. Iterate if needed
6. Document prompts in PHR (Prompt History Record)

### Quality Gates

Before considering implementation complete:

- [ ] All unit tests pass
- [ ] Integration tests pass
- [ ] Manual testing checklist 100% complete
- [ ] All 8 success criteria validated
- [ ] No regressions in Level 1/2 functionality
- [ ] Help text updated
- [ ] PHRs created for all significant AI interactions

### Deployment Readiness

- [ ] Code linted with ruff (no errors)
- [ ] Type checking with mypy passes (strict mode)
- [ ] All tests pass under pytest
- [ ] Demo video recorded (<90 seconds, shows recurring and reminders)
- [ ] README.md updated with Level 3 features

---

**Next Step**: Run `/sp.tasks` to generate detailed implementation tasks from this plan.
